[{"title":"学习《精通Javascript》笔记之面向对象的特性","date":"2016-07-22T07:08:32.000Z","path":"2016/07/22/《精通Javascript》学习笔记/","text":"学习《精通Javascript》笔记 《精通 Javascript 》作者是：【美国】 John Resig ,他是著名框架jQuery的作者,因此选择该作者的著作来拜读,可以对jQuery框架有更深刻的认识,也对JavaScript 会有更深刻的认识,这就是选择这本书的原因,我已经迫不及待了,让我们开始吧! 第一部分:面向对象的 JavaScript ​ 第一章,对 JavaScript 中较为经典的部分做了简单点评,该书的主要知识点将围绕以下5点进行展开: 面向对象的特性; 操作DOM; 注册事件(event) Javascript 与 CSS 的交互 Ajax的实现原理 第二部分:专业的 Javascript 开发 ​ 第二章,面向对象的 JavaScript 围绕面向对象的特性和细节进行了经典的描述和解释. 主要围绕着以下问题: ​ 1.引用(reference) ​ 2.作用域(scope) ​ 3.闭包(closure) ​ 4.上下文(context) 进行了详细的描述,这里,我就带着疑问和实践,一同和大家进行详细分析! 一,引用:&gt;概念:引用是面向对象实现的基础,而非一般的赋值的浅拷贝,你拿到的不是副本! 例如: 123456var obj = new Object() //实例化一个对象obj.name = &quot;小铭&quot;; //实例化一个对象var objRef = obj; //创建一个引用console.log(objRef.name) //结果是小铭objRef.name = &quot;大铭&quot;;console.log(obj.name) //结果是大铭 那么既然地址是相同的,如果我更改obj的地址指向时,objRef也应该修改才对(接着上一个代码) 123obj = new object(); //将obj从新赋一个新对象console.log(objRef.name) // 大铭console.log(obj.name) // undefined 然而实际情况却是objRef依然指向的是旧的对象 这就意味着,在 Javascript 中的 new 操作,实际上是创建了一个新的对象 ,而非改变原有地址,而原地址由于有引用,也没有被垃圾回收机制回收; 在 Javascript 中的=号都是”引用”符号而非赋值! 所以你常见的:字符串,数字,数组,布尔值,function,对象的=号其实都是引用 ; 1234var str = &quot;hellow world&quot;;var strRef = str; //这是引用var num = 100 ;var numRef = num; //这是引用 当你看到这里,你会疑惑,那为什么对象中的引用,在对象进行修改时引用中的值也会进行修改,而上面几行代码在改变 str 之后 strRef 并没有做出相应的改变啊?他们难道不是指向同一地址的吗? ​ 我们看原话: 引用( reference )的概念是 Javascript 的基础之一,”引用”是一个指向对象实际位置的指针,但是有一个前提:实际的对象肯定不是引用。字符串永远是字符串，数组永远是数组。不过多个变量却指向同一对象。JavaScript 基于的就是这样的引用系统。此外，对象可以包含一系列的属性（property），这些属性也都不过是其他对象的引用，一旦该对象的类型改变，则所有的引用也都会改变 123var str = &quot;hellow world&quot;; //创造一个实际赋值,在window上声明一个引用指向赋值的地址;var strRef = str; //这是引用str += &quot;new&quot;; 这段话的大意是说:上面的str 是 “hellow world”的引用,而 strRef 又是 str 的引用,当 str =”new” 时,实际上str 指向了创建的新的值,而 strRef 还是指向原来值的位置,因此strRef并没有随之而改变;在实际使用中将 strRef 看做str的副本拷贝表面上看也没有上面毛病,新手都是这样过来的,但稍微一思考,为什么strRef也可以调用到String的方法呢?侧面说明了strRef 事实上是个引用,想想在其他语言里面,如果只是拷贝的话,那么我们对strRef的操作就是调用其他对象的方法来进行加工而非调用方法,我们也可以通过这样的方法来验证; 12var str = new String(&quot;some&quot;);console.log(str); 你在打印的对象中会发现一个隐藏的属性[[PrimitiveValue]]; 而我们实际上需要的并不是一个对象,而是一个值,在函数中是这样写的 12var str = String(&quot;some&quot;);console.log(str); 在这里我们实际上就是调用了 String 的构造函数,该构造函数直接执行时 return 出了一个属性,但是由于[[PrimitiveValue]]属性被浏览器隐藏起来了([[]]代表浏览器中的隐藏属性),我也只能够猜测大概是这样的 1234function String(str)&#123; return this.PrimitiveValue = str;&#125;var str = String(&quot;some&quot;); 但是你又会疑惑,我们平时都是这样声明一个字符串的呀?怎么会调用到构造函数呢? 12var str = &quot;some&quot;;console.log(str.constructor == String); //true; 看完这句话,又会有新的疑惑,你确定 var 出来值是一个引用?而不是只有对象才有引用吗?请看原话第二段,对象可以包含一系列的属性,这些属性也都不过是其他对象的引用, 而 var 出来的变量实际上也是 window 对象的一个属性,使用引用的好处就在于,所有的引用都指向了原对象,那么也就可以直接调用原对象的方法,而不是使用元对象的方法进行加工.配合链式调用,可以减少变量的创建,进而减少内存的分配; 可以看下方拓展,这样就能够理解:所有=号实际上都是引用符号,而改变其中一个引用的指向,并不会影响另一个引用,非对象的引用每次赋值都是改变引用的指向 而由于原引用一直指向内存,因此原引用并不会被垃圾回收机制所回收:所以代码能够使用链式调用的地方就尽量不要创建新的引用; 拓展:如果说Javascript一切皆对象,那么Javascript都有哪些对象? EMCAJavascript 5.1中的对象本地对象(Native objects): ​ 本地对象有时被称为“全局对象”,”ES规范对象”，因为它们是JavaScript本来可以使用的对象。不要将术语全局对象(global)与作为作用域链的最高级别的“head”全局对象混淆，例如，所有Web浏览器中的“window”对象（head）; 下面列出了用JavaScript预先打包的9个本地对象构造函数：​ Number（）String（）Boolean（）Object（）Array () Function（）Date（）RegExp（）Error JavaScript主要是从这9个对象（以及字符串，数字和布尔值 - 原始值 - 它们的相等性基于值不是参考）构造的。 如果你直接调用构造函数（Number（），String（）和Boolean（）），就返回一个复杂的对象。如果你只是在代码中表示一个数字，字符串或布尔值（原始值，如5，“foo”和true），那么构造函数将返回一个原始值，而不是一个复杂的对象值。 “window”/head对象 而所有 var 声明出来的变量都是 window 的一个属性,我们可以这样论证 123456var a= 2;for(x in window)&#123; if(window[x] === a)&#123; console.log(x) //a &#125;&#125; 如果你想看的更详细也可以 1console.log(this); 你如果你眼力够好会很容易找到其中的Window中的a的; 如果你打开Window对象会发现一个首字母小写window的属性.而点击小window又会打开一个新的window,无穷尽; 网络上,一种模糊的说法是, Window 是主机对象和本地对象交互的地方,个人认为 Window 是存储变量的地方也是dom,事件等方法存储并供浏览器调用的地方; 主机对象(Host objects) ​ 运行JavaScript代码的主机环境（例如web浏览器）通常提供head/window对象（例如web浏览器中的窗口对象），其中语言的本地部分与主机对象（例如web浏览器中的window.location）和用户定义的对象（例如您的写代码在Web浏览器中运行的代码）,简单来说,可以操作浏览器的对象都是属于主机对象.而存在兼容性问题 的代码都是出于主机对象当中; 函数重载(overload)和类型检查​ Java中的函数重载一般是指在实例对象中不满意父级的方法而进行重写覆盖,而书中原文中的重载是通过判断传入参数数量的能力和判断传入参数类型,这一点也是jQuery如此传奇的所在之处,也被后来的Vue.js等框架所吸收利用. JavaScript 中函数重载的两个例子: 例子一: 123456789101112131415161718function sendMessage( msg , obj)&#123; if( arguments.length == 2)&#123; obj.handleMsg(msg); &#125;else&#123; alert( msg); &#125;&#125;//仅用一个参数调用这个函数 - 用 alert 来显示此消息sendMessage( &quot;Hello, World!&quot; ); // 弹出 Hello, World!//又或者我们可以传入一个对象sendMessage( &quot;How are you?&quot;,&#123; handleMag:function(msg)&#123; alert(&quot;This is a custom message:&quot;+mag); &#125;&#125;) //弹出This is a custom message:How are you?//这里扩展一下,你就可以发现Vue.js中的new vue(&#123;&#125;)的内部实现其实也类似于这样的,以及commonJs中的配置文件,或者配置Json文档,当做一个对象传入配置器; 例子二: 1234567891011121314// 一个接受任意数量参数并将其转换为数组的函数function makeArray()&#123;//临时使用的数组var arr = [];//遍历传入的每个参数for(var i= 0;i&lt;arguments.length;i++)&#123;arr.push( arguments[i]);&#125;//结果返回数组return arr&#125;//这个再扩展一下,可以对比ES6中的promise或者angular中的$q,和监听者模式; 既然要使用函数重载,那么就需要判断参数传入的类型 判断类型的两种方法:typeof / .constructor, typeof 可以检测非对象类的参数 .constructor可以返回其构造器,是每一个对象都包含的属性 第一种大家已经用的很多了,那么我就只说一下第二种 例子: 123&#123;&#125;.constructor == Object; //true&quot;str&quot;.constructor == String //turefunction foo()&#123;&#125;;foo.construcot == Function //ture 作用域( scope ):ECMA Javascript 5.1中规定,只有函数级作用域和全局作用域,在浏览器加载脚本时,会将“声明”进行提升,也就是说在其它语言中可能报错的情况下,Js可能只会输出 undefined ; 例如: 12console.log(go);var go = 2; 实际上由于”声明提升”,浏览器将该变量变为了 123var go;console.log(go)go = 2; 对于声明的函数,也有”声明提升” 例如: 1234go();function go()&#123; console.log(&quot;hellow world!&quot;)&#125; 实际上由于”声明提升”,浏览器将声明的变量写为: 12function go()&#123;console.log(&quot;hellow world!&quot;)&#125;go(); 需要注意的是: 123456foo();var foo = function()&#123;&#125;;-----------提升------------var foo;foo();foo = function()&#123;&#125;; 该表达式说明了,”声明提升”只会提升等式左边的声明;而右边绝不可能有声明 而函数作用域内的声明也会被提前: 例如: 1234function go()&#123;console.log(a); //undefinedvar a = 2;&#125; 而对于函数作用域内声明过的变量被”声明提升”为: 12345function go()&#123;var a;console.log(a);a = 2;&#125; 对变量的查询方式 : ​ 会先在当前作用域中先进行查看,如果有则使用当前作用域内声明的变量,如果没有则向上一个作用域中去查找,因此一定要注意书写规范,凡是声明变量时在该变量出现在 “=” 左边之前就应该将值初始化 ; 综上几点结论就是:声明提前是浏览器编译Js代码时进行的隐式工作,必须要谨慎对待,凡是声明时便对其赋值 ,可以有效的避免该错误; 拓展:ES6中的作用域规范​ ES6中新增了块级(block)作用域,更符合后端人员的口味,也使得Js代码更规范和健壮,为此新增了let 和 const 来进行块级作用域的声明,例如那个闭包经典问题,在for循环中引用的外全局变量不再是计算过的值,而是被定义时的值,而非执行时的值! ​ 1.let 命令:使用let进行声明的变量将不会提前,无论他在哪里(函数内,全局,块),但是在函数作用域内,虽然不会提升,但是会造成一个“暂时性死区”（temporal dead zone，简称 TDZ）,也就是在(块,函数内)如果有和上一作用域的声明冲突,那么在let声明之前都无法读取到该声明; 也就是说 12345678910111213if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125;//解决的方法就是,如果需要获取到作用域外的某变量时,作用域内不要有重复声明!!//如果有,尽量保持声明写在区域作用域的顶部 ES6规定了块级作用域内也能够声明函数,但该函数无法在块级作用域外使用 由于变量无需提升,那么let将会逐行解析 闭包(closure) 闭包( closure )意味着内层的函数可以引用存在包围它的函数内的变量, 即使外层函数的执行已终止. 闭包,的常用方式, 一、用来封装一些函数，可以减少引用的存在，例如： 12345function gitTime(msg, time)&#123; setTimeout(function()&#123; alert(msg) &#125;,time);&#125; 二、使用闭包来隐藏全局作用域变量 (当然在ES6中解决了这个问题) 123456(function()&#123;var msg = &quot;Thanks for visiting&quot;; window.onunload = function()&#123; alert(msg) &#125;&#125;)(); 闭包的经典问题: 假设有10个div. 1234567var div = document.querySelectorAll(&quot;div&quot;);for(var i = 0;i &lt; 10;i++)&#123; div[i].onclick = function()&#123; console.log(i); &#125;&#125;//答案大家都知道,无论你点哪一个div都会打印10; 书中说函数内拿到的是最终值,但并没有说明原因:我认为这是因为当执行该函数时,执行的位置已经在循环执行完之后,因此如果将函数的调用放在当前即可解决该问题,这也使用了闭包的作用,引用了外层函数的值,当外层函数销毁,内层函数的值不会被销毁因此虽然函数执行完毕,但是i由于有了内部的引用并不会被销毁,当外层函数执行完毕之后,由于i的值被赋予内部进行引用,因此并没有销毁; 123456789var div = document.getElementsByTagName(&quot;div&quot;);for(var i = 0;i &lt; div.length;i++)&#123;function foo(i)&#123; div[i].onclick = function()&#123; console.log(i); &#125;&#125;foo(i);&#125; 当然,为了节省引用 可以使用匿名函数来进行包装 12345678var div = document.getElementsByTagName(&quot;div&quot;);for(var i = 0;i &lt; div.length;i++)&#123;(function (i)&#123; div[i].onclick = function()&#123; console.log(i); &#125;&#125;)(i);&#125; 如果觉得晦涩难懂也可以写成这个样子 123456789var div = document.getElementsByTagName(&quot;div&quot;);for(var i = 0;i &lt; div.length;i++)&#123; div[i].onclick = wrap(i); function wrap(i)&#123; return function ()&#123; console.log(i); &#125; &#125;&#125; 这就是外层函数虽然销毁,但是内层函数对外层函数的引用依然存在 这就是闭包应用的场景,当我们需要延迟执行某一个函数时,而该函数需要引用外部的值,但是该值的计算又提前于函数执行之后,那么就可以使用闭包来解决该问题 上下文 在 JavaScript 中,代码总是有一个上下文对象(代码处在该对象内)。上下问对象是通过 this 变量体现的,这个变量永远指向当前代码所处的对象中。即使是在全局变量中 this 也是指向 widow 对象的。 1.在上下问对象内使用函数并将其上下文对象切换为另一个变量； 123456789var obj = &#123; yes:function()&#123; 此时的this指向的是obj this.var = true; &#125;, no: function()&#123; this.val = false; &#125; &#125; 讲到这,绝大多数新手都会范一个错误; 1234var obj=&#123; this.val = 10, this.name = &quot;xiaoming&quot;&#125; 这里注意 var出来的对象,最终调用者其实是window,不要忘记上面有关引用的拓展知识; 因此需要使用函数来切换 this 的指向,至于为什么要这样,我只能说函数本身就有此功能,因为任何函数都可以是构造函数,他都有构造器和函数原型,当他们作为属性时,this 时指向的是自身的对象; 例如: 我们在全局中声明的函数实际上是window对象的一个属性 1234function foo(name)&#123; console.log(this) //打印出window对象 this.name = name&#125; 对于构造函数或者函数中方法我们可以使用call和apply改变上下文 例如: 1234接上个例子:var a = &#123;&#125;;foo.call(a,&quot;hellow&quot;);console.log(a.name) call在调用时就相当于执行了该函数的方法,并将上下文对象指向了传入的对象, 这样我们可以看到比较经典的例子 12345function foo(name,age)&#123; var newArr = Array.prototype.slice.call(arguments); console.log(newArr);&#125;foo(&quot;xiaoming&quot;,20); 由于arguments是一个伪数组,并不可以使用Array原型中的方法,对于数组的方法我们没办法使用,就可以使用call方法借调数组原型中的方法,当然一切皆对象,虽然一般没人这样写,但是为了更进一步理解,我们也写了下面的例子: 123456function foo(name)&#123; var name = name; var arr = String.prototype.split.call(name,&quot;&quot;); console.log(arr);&#125;foo(&quot;xiaoming&quot;); 也就是说凡是其他函数中用this写的操作,我们都可以写成上面这种方式进行调用; 甚至dom对象也可以通过该方法调用,简直就是方便的不要不要的,比如原文中的这个案例: 12345function setColor(color)&#123; this.style.backgroundColor = color;&#125;var body = document.body;setColor.call(body,&quot;red&quot;); 当然为了简化和让代码看起来干净,目的明确,原文中写成 1234567function setColor(color)&#123; this.style.backgroundColor = color;&#125;function setBodyColor(color)&#123; setColor.call(document.body,color);&#125;setBodyColor(&quot;red&quot;); (那,当变量名无法展示该行代码的功能时,我们就有必要对该行代码进行封装) 还有一种不容易看出来的上下文就是事件中的上下文,事件中的this,是指向调用该事件的元素; 1234var div = document.queryselector(&quot;div&quot;);div.onclick = function()&#123; this.style.backgroundColor = blue&#125; 面向对象的基础面向对象的基础小节当中主要分为以下几个知识点 1.对象 2.自定义对象的创建 3.静态方法 对象的基础知识大家基本都有理解,那么我们从创建开始讲起: 原文案例: 1234567function User()&#123; this.name = &quot;go&quot;;&#125;//通过构造器创建一个 User 对象var me = new User();var you = new me.constructor();console.log(me.constructor == you.constructor); 事实上每一个对象的都是通过构造器创建的,这样的创建缺点就是,实例中每一个从构造器继承过来的属性都被隐式的创建了新的引用; 接上一个案例: 1234me=&#123;&#125;;me.name = &quot;go&quot;;you = &#123;&#125;;you.name = &quot;go&quot;; 你的疑惑就是,”我知道了,原来是这样,但是并没有什么问题啊”,问题就在于如果内部有一个方法,那么他也会被拷贝多份,这样也占用了大量的内存; 公共方法(public method)因此除了构造器继承以外,还有原型继承,对于的是原文中的:公共方法 原文案例: 123456789function User(name,age)&#123; this.name = name; this.age = age;&#125;;User.prototype.getName = function()&#123;return this.name&#125;;User.prototype.getAge = function()&#123;return this.age&#125;;var user = new User(&quot;Bob&quot;,44);alert( user.getName() == &quot;Bob&quot;);alert( user.getAge() == &quot;44&quot;); 这样的好处就是,公共方法中所有实例化的对象都无需创建新的引用便可以使用,可以优化内存 私有方法(private method)原文案例: 12345678910function Classroom( students, teacher)&#123; function disp()&#123; alert(this.names.join(&quot;,&quot;)); &#125; this.students = students; this.teacher = teacher; disp();&#125;var class = new Classroom([&quot;John&quot;, &quot;Bob&quot;], &quot;Mr.Smith&quot;)class.disp(); //调用失败,因为disp()是一个私有方法; 原文解释: 私有方法和私有变量在保证代码没有冲突的同时,允许你对用户能使用和能看到的内容有更好的控制. 个人理解: ​ 完美报错,错误一:this.names并没有值;是一个undefined; ​ 错误二:占用了class关键字 ​ 这是由于书籍版本的原因,历史原因在此不作讨论了,也不能说人家就错,但是错误一就有点奇怪了,应该再传入一个参数给this.names;应该写为如下 12345678910function Classroom( students, teacher,name)&#123; function disp()&#123; this.names = name console.log(this.names) &#125; this.students = students; this.teacher = teacher; disp();&#125;var class = new Classroom([&quot;John&quot;, &quot;Bob&quot;], &quot;Mr.Smith&quot;,&quot;myName&quot;) 这样,在new一个对象时,也可以做一些操作; 特权方法(privileged method) 用来指代那些在查看并处理(对象中)私有变量的同时允许用户以公共方法的方式访问的方法; 原文案例: 123456789function User(name ,age)&#123; var year = (new Date()).getFullYear() - age; this.getYearBorn = function ()&#123; return year; &#125;;&#125;var user = new User(&quot;Bob&quot;,44);alert(user.getYearBorn() == 1973); //turealert(user.year == null); 本质上,特权方法是动态生成的,因为他们是运行时才添加到对象中的,而不是在代码第一次编译时就已经生成的.虽然这个技巧要比对象的原型继承开销更大,但工功能也更强、和灵活 这里原文中写的很好，就不再解析了； 4.静态方法（static method） 静态方法的实质与任何其他的一般函数没有什么不同,最主要的区别在于,其他函数是以对象的静态属性形式存在的.作为一个属性他们不能在该对象的实例的上下稳中访问,而只属于主对象本身的那个上下文中. 实际上,这样编写代码的唯一有点是保证对象命名空间的整洁 原文例子: 123456User.cloneUser = function(user)&#123; return new User&#123; user.getName(), user.getAge() &#125;&#125; 拓展,这也是 jQuery 中仅仅只使用一个 $ 就可以将所有函数封装的方式,因此在编写功能性强大的框架时,可以使用该方法保持清洁的命名空间; 面向对象的基础小结 开发出专业的 javascript 代码的根本方法之一是,快速、静态地提供与其他代码的接口，同时保证自身的可理解性！ 拓展为了扩展视野,我们来看jQuery中的源码仿写: 12345678910111213141516(function()&#123; var A = function(num)&#123; return A.fn.init(num) &#125;; A.fn = A.prototype=&#123; init:function(num)&#123; this.ele = num; return this; &#125;, print:function()&#123; console.log(this.ele); &#125; &#125; window.$ = A; &#125;)(); $(&apos;20&apos;).print(); 这是多么有艺术的一段代码啊!如果觉得有些负责也没有关系，在本文最后,我会为大家带来Jquery封装的实现的步骤和推演,让你轻松看懂这段代码的艺术,但现在,我们还需要学习更多知识来做为储备; 创建可重用的代码标准化面向对象的代码原型式继承​ 从原文中仿写的例子: 123456789101112function User()&#123; this.name = &quot;jhon&quot;;&#125;;User.prototype.getName = function()&#123; return this.name;&#125;;function Person()&#123;&#125;;Person.prototype = new User(); //重点理解!var person = new Person();console.log(person.name); //jhon 这段代码的作用是在以后通过 Person 实例化后的对象,都拥有了 User 的方法,当然后面还讲到了通过该继承方式来进行模拟 Java 语言中的 类继承 的例子,但是ES6中有类似功能,因此在此只作为理解使用; 该例子隐藏了很多个知识点: 1.当创建一个对象实例时,该对象的__proto__属性指向了父级对象 例如: 12345function Person()&#123; this.name = &quot;jhon&quot;&#125;var obj = new Personconsole.log(obj.__proto__); 可以打印person.__proto__来进行查看; 2.当一个对象实例查找一个属性时,会先从自身属性查找,当自身没有时会查找构造函数的构造器,当构造器中也没有时将查找到构造函数的原型 后面的更多写的是基于上面这个例子所写的一些其他人写的仿Class继承的类库,由于ES6实现了很多类似的继承,那么不再拓展,面向对象这一篇章也就算完结了,现在是看这书的第5天,看书工作加消化和书写,也是一场知识与脑力的碰撞,可能写的有点乱,如果有不妥的地方,可以联系我哟.也请如果有转载,请注明出处,谢谢!文章最后的JQ仿写可以参考我的另外一篇文章 !《Jquery仿写》 ### ​ ​ ​","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"CSS3动画","date":"2015-05-29T04:25:21.000Z","path":"2015/05/29/CSS3动画/","text":"CSS3动画通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。 1、转换 transform实现对元素的移动、缩放、转动、倾斜。转换是使元素改变形状、尺寸和位置的一种效果。 可以使用 2D 或 3D 转换来转换您的元素。 浏览器支持Internet Explorer 10、Firefox、Opera 支持 transform 属性。 Internet Explorer 9 支持替代的 -ms-transform 属性（仅适用于 2D 转换）。 Safari 和 Chrome 支持替代的 -webkit-transform 属性（3D 和 2D 转换）。 Opera 只支持 2D 转换。 语法1transform: none|transform-functions; 值 描述 none 定义不进行转换。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate(x,y) 定义 2D 转换。 translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。 translateY(y) 定义转换，只是用 Y 轴的值。 translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿着 X 轴的 3D 旋转。 rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n) 为 3D 转换元素定义透视视图。 2Dtransform-styletransform-style: flat; 默认值，表示所有子元素在2D平面呈现（设置在父元素中） transform-origin指定元素的原点transform-orign :center（默认，中心点）transform-orign: left centertransform-orign: 40% 50%transform-orign: 20px 30px translate 平移translate(x, y)​ 沿着X和Y轴移动元素，参数为像素值translateX(n)​ 沿着X轴移动translateY(n)​ 沿着Y轴移动 scale 缩放scale(x, y)​ 改变元素的宽度和高度，参数为缩放倍数scaleX(n)​ 改变元素的宽度scaleY(n)​ 改变元素的高度 rotate 旋转rotate(angle)​ 参数为旋转角度，单位deg skew 倾斜/斜切skew(x-angle, y-angle)​ 参数为倾斜角度，单位degskewX(angle)skewY(angle) 3Dtransform-styletransform-style: preserve-3d 表示所有子元素在3D空间中呈现（设置在父元素-也就是舞台元素中） perspectiveperspective: 20000px;​ 设置镜头距离 或者叫 透视距离 子元素会起作用(用在舞台元素上)transform: perspective(20000px);​ 用在当前变形元素上，效果同上 perspective-origin用来决定perspective属性的源点角度，实际设置了x轴和y轴的位置属性值是像素值或者百分比，或者（left/center/right，top/center/bottom） 默认为（50%，50%） backface-visibility决定元素旋转背面是否可见属性值为visible(默认值，反面可见)/hidden(反面不可见) translate 平移translate3d(x, y, z)translateZ(n) scale 缩放scale3d(x, y, z)scaleZ(n) rotate 旋转rotate3d(1,1,1,45deg)前三个 参数中最大的值 代表把后面的角度分为多少份 然后三个值分别占几分 最后一个参数为角度rotateX(n)rotateY(n)rotateZ(n) 2、过渡 transition通过transition，我们可以在不使用Flash动画或JS的情况下， 当元素从一种样式变换为另一种样式时为元素添加效果。IE9及之前版本不支持 transition-property规定应用过渡的CSS属性的名称 transition-duration定义过渡效果花费的时间。默认是0 transition-timing-function规定过渡效果的时间曲线。默认ease 语法12transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n); 值​ linear 匀速运动​ ease 慢，快，慢​ ease-in 慢，快​ ease-out 快，慢​ ease-in-out 慢，快，慢 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 transition-delay规定过渡效果延迟时间。默认0 transition复合属性，用于在一个属性中设置四个过渡属性（至少设置两个属性值：样式名称 过渡时间）可以同时改变多个属性的过渡 以”,” 进行分隔, 如 transition: width 3s,height 3s,margin-left 3s,margin-top 3s 触发过渡伪元素触发 如 ：hover媒体查询触发js事件触发 3、动画 animation关键帧 @keyframes@keyframes 动画名 {​ from {​ }​ to {​ } } @keyframe 动画名 {​ 0% {​ }​ 50% {​ }​ 100% {​ } } 定义和用法通过 @keyframes 规则，您能够创建动画。 创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。 在动画过程中，您能够多次改变这套 CSS 样式。 以百分比来规定改变发生的时间，或者通过关键词 “from” 和 “to”，等价于 0% 和 100%。 0% 是动画的开始时间，100% 动画的结束时间。 为了获得最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 注释：请使用动画属性来控制动画的外观，同时将动画与选择器绑定。 语法1@keyframes animationname &#123;keyframes-selector &#123;css-styles;&#125;&#125; 值 描述 animationname 必需。定义动画的名称。 keyframes-selector 必需。动画时长的百分比。 合法的值： 0-100% from（与 0% 相同） to（与 100% 相同） css-styles 必需。一个或多个合法的 CSS 样式属性。 实例1、在一个动画中添加多个 keyframe 选择器： 1234567891011121314151617181920212223242526@keyframes mymove&#123; 0% &#123;top:0px;&#125; 25% &#123;top:200px;&#125; 50% &#123;top:100px;&#125; 75% &#123;top:200px;&#125; 100% &#123;top:0px;&#125;&#125;@-moz-keyframes mymove /* Firefox */&#123; 0% &#123;top:0px;&#125; 25% &#123;top:200px;&#125; 50% &#123;top:100px;&#125; 75% &#123;top:200px;&#125; 100% &#123;top:0px;&#125;&#125;@-webkit-keyframes mymove /* Safari 和 Chrome */&#123; 0% &#123;top:0px;&#125; 25% &#123;top:200px;&#125; 50% &#123;top:100px;&#125; 75% &#123;top:200px;&#125; 100% &#123;top:0px;&#125;&#125; 2、在一个动画中改变多个 CSS 样式： 1234567891011121314151617181920212223@keyframes mymove&#123; 0% &#123;top:0px; background:red; width:100px;&#125; 100% &#123;top:200px; background:yellow; width:300px;&#125;&#125;@-moz-keyframes mymove /* Firefox */&#123; 0% &#123;top:0px; background:red; width:100px;&#125; 100% &#123;top:200px; background:yellow; width:300px;&#125;&#125;@-webkit-keyframes mymove /* Safari 和 Chrome */&#123; 0% &#123;top:0px; background:red; width:100px;&#125; 100% &#123;top:200px; background:yellow; width:300px;&#125;&#125;@-o-keyframes mymove /* Opera */&#123; 0% &#123;top:0px; background:red; width:100px;&#125; 100% &#123;top:200px; background:yellow; width:300px;&#125;&#125; 3、带有多个 CSS 样式的多个 keyframe 选择器： 1234567891011121314151617181920212223242526272829303132333435@keyframes mymove&#123; 0% &#123;top:0px; left:0px; background:red;&#125; 25% &#123;top:0px; left:100px; background:blue;&#125; 50% &#123;top:100px; left:100px; background:yellow;&#125; 75% &#123;top:100px; left:0px; background:green;&#125; 100% &#123;top:0px; left:0px; background:red;&#125;&#125;@-moz-keyframes mymove /* Firefox */&#123; 0% &#123;top:0px; left:0px; background:red;&#125; 25% &#123;top:0px; left:100px; background:blue;&#125; 50% &#123;top:100px; left:100px; background:yellow;&#125; 75% &#123;top:100px; left:0px; background:green;&#125; 100% &#123;top:0px; left:0px; background:red;&#125;&#125;@-webkit-keyframes mymove /* Safari and Chrome */&#123; 0% &#123;top:0px; left:0px; background:red;&#125; 25% &#123;top:0px; left:100px; background:blue;&#125; 50% &#123;top:100px; left:100px; background:yellow;&#125; 75% &#123;top:100px; left:0px; background:green;&#125; 100% &#123;top:0px; left:0px; background:red;&#125;&#125;@-o-keyframes mymove /* Opera */&#123; 0% &#123;top:0px; left:0px; background:red;&#125; 25% &#123;top:0px; left:100px; background:blue;&#125; 50% &#123;top:100px; left:100px; background:yellow;&#125; 75% &#123;top:100px; left:0px; background:green;&#125; 100% &#123;top:0px; left:0px; background:red;&#125;&#125; animation-name指定关键帧动画的名字，这个动画名必须对应一个@keyframes规则 请始终规定 animation-duration 属性，否则时长为 0，就不会播放动画了。 浏览器支持Internet Explorer 10、Firefox 以及 Opera 支持 animation-name 属性。 Safari 和 Chrome 支持替代的 -webkit-animation-name 属性。 Internet Explorer 9 以及更早的版本不支持 animation-name 属性。 注意: 下面的其他动画的属性浏览器支持情况同animation-name 语法1animation-name: keyframename|none; 值 描述 keyframename 规定需要绑定到选择器的 keyframe 的名称。 none 规定无动画效果（可用于覆盖来自级联的动画）。 实例为 @keyframes 动画规定一个名称： 12345div&#123; animation-name:mymove; -webkit-animation-name:mymove; /* Safari 和 Chrome */&#125; animate-duration:设置动画持续时间 语法1animation-duration: time; 值 描述 time 规定完成动画所花费的时间。默认值是 0，意味着没有动画效果。 实例：动画执行时间为2秒 12345div&#123; animation-duration:2s; -webkit-animation-duration:2s; /* Safari 和 Chrome */&#125; animation-timing-function:animation-timing-function: ease-in-out; 规定动画的速度曲线。速度曲线定义动画从一套 CSS 样式变为另一套所用的时间。 速度曲线用于使变化更为平滑。 动画播放效果，与transition-timing-function类似 语法1animation-timing-function: value; animation-timing-function 使用名为三次贝塞尔（Cubic Bezier）函数的数学函数，来生成速度曲线。您能够在该函数中使用自己的值，也可以预定义的值： 值 描述 linear 动画从头到尾的速度是相同的。 ease 默认。动画以低速开始，然后加快，在结束前变慢。 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 实例从开头到结尾以相同的速度来播放动画： 12345div&#123; animation-timing-function:2s; -webkit-animation-timing-function:2s; /* Safari 和 Chrome */&#125; animation-delay:定义动画动画延迟时间，animation-delay 值以秒或毫秒计。 提示：允许负值，-2s 使动画马上开始，但跳过 2 秒进入动画。 语法1animation-delay: time; 值 描述 time 可选。定义动画开始前等待的时间，以秒或毫秒计。默认值是 0。 实例等待两秒，然后开始动画： 12345div&#123; animation-delay:2s; -webkit-animation-delay:2s; /* Safari 和 Chrome */&#125; animation-iteration-count定义动画的播放次数，infinite为无限次 animation-iteration-count: 10; 定义循环次数, infinite为无限次 语法1animation-iteration-count: n|infinite; 值 描述 n 定义动画播放次数的数值。 infinite 规定动画应该无限次播放。 实例播放动画三次： 12345div&#123; animation-iteration-count:3; -webkit-animation-iteration-count:3; /* Safari 和 Chrome */&#125; animation-direction指定动画的播放方向，如果 animation-direction 值是 “alternate”，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等）向后播放。 注释：如果把动画设置为只播放一次，则该属性没有效果。 语法1animation-direction: normal|alternate; 值 描述 normal 默认值。动画应该正常播放。 alternate 交替轮流，动画应该轮流向前/反向播放 实例暂停动画： 12345div&#123; animation-direction: alternate; -webkit-animation-direction: alternate; /* Safari 和 Chrome */&#125; animation-play-state设置动画的播放状态，运行还是暂停 语法1animation-play-state: paused|running; 值 描述 paused 规定动画已暂停。 running 规定动画正在播放。默认）从开始或者暂停的位置重新播放 animation-fill-mode属性规定动画在播放之前或之后，其动画效果是否可见。 其属性值是由逗号分隔的一个或多个填充模式关键词。 语法1animation-fill-mode : none | forwards | backwards | both; 值 描述 none 不改变默认行为。动画结束后返回初始帧处 forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。动画结束后继续应用最后帧的位置 backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 both 向前和向后填充模式都被应用。动画同时具有forwards和backwards的效果 实例为 h1 元素规定填充模式： 1234h1&#123; animation-fill-mode: forwards;&#125; animation复合属性animation 属性是一个简写属性，复合属性，用于设置六个动画属性： animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction 注释：请始终规定 animation-duration 属性，否则时长为 0，就不会播放动画了。 语法1animation: name duration timing-function delay iteration-count direction; 值 描述 animation-name 规定需要绑定到选择器的 keyframe 名称。 animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。 animation-direction 规定是否应该轮流反向播放动画。 实例12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt; &lt;style&gt; div &#123; width:100px; height:100px; background:red; position:relative; animation:mymove 5s infinite; -webkit-animation:mymove 5s infinite; /*Safari and Chrome*/ &#125; @keyframes mymove &#123; from &#123;left:0px;&#125; to &#123;left:200px;&#125; &#125; @-webkit-keyframes mymove /*Safari and Chrome*/ &#123; from &#123;left:0px;&#125; to &#123;left:200px;&#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}]},{"title":"CSS3简介","date":"2015-05-20T06:03:21.000Z","path":"2015/05/20/CSS3简介/","text":"CSS3介绍CSS版本 CSS1: 定义了网页的基本属性：字体，颜色，补白，基本选择器等等。CSS2：添加了高级功能：浮动，定位，高级选择器（子选择器，相邻选择器，通用选择器）CSS3：遵循模块化开发。发布时间并不是一个时间点，而是时间段。（2002-至今） CSS3选择器css3开始新增新特性（1）CSS选择器 ​ http://www.w3school.com.cn/cssref/css_selectors.asp ​ http://www.cnblogs.com/libingql/p/4375354.html（2）新的颜色制式和透明设定 ​ http://blog.csdn.net/u012612399/article/details/50205485（3）多栏布局的实现 ​ http://blog.csdn.net/cinderella_hou/article/details/52155185 ​ http://www.diannao.wang/css/2015/48-14305.html（4）多背景图效果 ​ http://caibaojian.com/css3-multiple-background.html（5）文字阴影效果（6）开放的网络字体类型 ​ http://blog.csdn.net/u014328357/article/details/52859321（7）圆角（8）边框背景图片（9）盒子阴影（10）媒体查询 1、伪元素选择器:first-line匹配内容的第一行 :first-letter匹配内容的第一个字符 :before在元素内容之前插入一些内容，需要配合content属性 :after在元素之后插入一些内容，需要配合content属性 常用于清除浮动 #ff:after { content: ‘’; clear: both; display: block; *zoom: 1;} ::selection选中的时候文字的样式 IE9支持，火狐得加-moz- 谷歌支持 只接受两个属性 background, color 2、目标伪类选择器:target使用target选择器对页面中的某个target元素(锚点)指定样式 该样式只在用户点击了页面中的超链接,并且跳转到target元素后起作用 可用于实现tab切换 3、状态伪类选择器:focus获取焦点的时候触发 :disabled设置禁用状态下的样式 :enabled设置没有被禁用状态下的样式 :read-only只读 :read-write可读可写 :checked给单选、多选设置选中的样式 4、结构伪类选择器:root匹配页面的根元素 :empty内容为空的元素 :first-child在父元素下找第一个子元素 :last-child在父元素下找最后一个子元素 :nth-child(n)在父元素下找第n个子元素（ n是从1开始的整数） :nth-last-child(n)在父元素下找倒数第n个子元素 :only-child父元素下只有唯一 一个元素则生效 :nth-child(odd)父元素下序号为奇数的子元素，也可以写成:nth-child(2n-1) :nth-child(even)父元素下序号为偶数的子元素，也可以写成:nth-child(2n) :first-of-type在父元素下找第一个指定元素（不计算其余类型的元素） :last-of-type在父元素下找最后一个指定元素 :nth-of-type(n)在父元素下找指定元素 第n个（ n是从1开始的整数） :nth-last-of-type(n)在父元素下找指定元素 倒数第n个 :only-of-type父元素只包含一个同类型的子元素时生效（可以有多个其余类型的子元素） 5、否定伪类选择器:not( )除了括号内的元素 6、层次选择器E+F相邻(后一个)兄弟选择器 E~F通用(后面所有)兄弟选择器 7、属性选择器E[attr]选择带有attr属性的所有E元素，支持E[attr1] [attr2]多属性选择器 E[attr = val]选择带有attr属性且属性值为val的所有E元素 E[attr |= val]选择带有attr属性且属性值为val或者以var-开头的所有E元素 E[attr ~= val]选择attr属性包含一个或多个属性值（用空格隔开），其中一个值为val 的所有E元素 E[attr *= val]选择带有attr属性且属性值包含字符串‘val’（如vals，value等） 的所有E元素 E[attr ^= val]选择带有attr属性且属性值为以var开头的所有E元素（与E[attr |= val]的区别是不需要-） E[attr $= val]选择带有attr属性且属性值为以var结尾的所有E元素。运用在一些特殊的链接加背景图很方便， 比如给PDF/PNG/DOC等不同文件加不同ICON图标，a[href $= png] CSS3其他1、文字阴影text-shadow：x轴偏移量 y轴偏移量 阴影模糊半径(可省略) 阴影颜色 2、单词换行word-break:break-all/break-word 3、盒子阴影box-shadow：x轴偏移量 y轴偏移量 阴影模糊半径(可省略) 阴影大小(可省略) 阴影颜色 4、圆角border-radius4个参数：左上 右上 右下 左下3个参数：左上 右上/左下 右下2个参数：左上/右下 右上/左下1个参数：所有角 参数可以是像素值或百分比(相对自身宽高) 5、图片边框border-imagesource图片路径 slice图片边框向内偏移,用来分解引入的图片,拆分成九宫格例如:border-image-slice:10 10 10 10 width图片边框宽度 outset边框图像区域超出边框的量 repeat边框是否应平铺(repeated),铺满(round),拉伸(stretch) 6、背景图片大小background-size像素值/百分比如果只写一个,第二个默认auto cover等比例缩放到完全覆盖容器，背景图像有可能超出容器 contain完全包含图片，一端完全撑开，另一端等比例缩放 auto真实大小 background-positioncenter center 保证图片拉伸后，视觉中心在最中间 7、渐变线性渐变​ background: linear-gradient(0deg,red,yellow,green)​ 第一个参数多种写法​ to left bottom​ to bottom​ 10deg 弧形渐变​ background: radial-gradient(at left top,red,yellow)​ 第一个参数不写默认在中间 CSS性能优化http://www.jianshu.com/p/268c7f3dd7a6 http://blog.jobbole.com/35339/","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]}]