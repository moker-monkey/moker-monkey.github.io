[{"title":"学习《精通Javascript》笔记之面向对象的特性","date":"2016-07-22T07:08:32.000Z","path":"2016/07/22/《精通Javascript》学习笔记/","text":"学习《精通Javascript》笔记 《精通 Javascript 》作者是：【美国】 John Resig ,他是著名框架jQuery的作者,因此选择该作者的著作来拜读,可以对jQuery框架有更深刻的认识,也对JavaScript 会有更深刻的认识,这就是选择这本书的原因,我已经迫不及待了,让我们开始吧! 第一部分:面向对象的 JavaScript ​ 第一章,对 JavaScript 中较为经典的部分做了简单点评,该书的主要知识点将围绕以下5点进行展开: 面向对象的特性; 操作DOM; 注册事件(event) Javascript 与 CSS 的交互 Ajax的实现原理 第二部分:专业的 Javascript 开发 ​ 第二章,面向对象的 JavaScript 围绕面向对象的特性和细节进行了经典的描述和解释. 主要围绕着以下问题: ​ 1.引用(reference) ​ 2.作用域(scope) ​ 3.闭包(closure) ​ 4.上下文(context) 进行了详细的描述,这里,我就带着疑问和实践,一同和大家进行详细分析! 一,引用:&gt;概念:引用是面向对象实现的基础,而非一般的赋值的浅拷贝,你拿到的不是副本! 例如: 123456var obj = new Object() //实例化一个对象obj.name = \"小铭\"; //实例化一个对象var objRef = obj; //创建一个引用console.log(objRef.name) //结果是小铭objRef.name = \"大铭\";console.log(obj.name) //结果是大铭 那么既然地址是相同的,如果我更改obj的地址指向时,objRef也应该修改才对(接着上一个代码) 123obj = new object(); //将obj从新赋一个新对象console.log(objRef.name) // 大铭console.log(obj.name) // undefined 然而实际情况却是objRef依然指向的是旧的对象 这就意味着,在 Javascript 中的 new 操作,实际上是创建了一个新的对象 ,而非改变原有地址,而原地址由于有引用,也没有被垃圾回收机制回收; 在 Javascript 中的=号都是”引用”符号而非赋值! 所以你常见的:字符串,数字,数组,布尔值,function,对象的=号其实都是引用 ; 1234var str = \"hellow world\";var strRef = str; //这是引用var num = 100 ;var numRef = num; //这是引用 当你看到这里,你会疑惑,那为什么对象中的引用,在对象进行修改时引用中的值也会进行修改,而上面几行代码在改变 str 之后 strRef 并没有做出相应的改变啊?他们难道不是指向同一地址的吗? ​ 我们看原话: 引用( reference )的概念是 Javascript 的基础之一,”引用”是一个指向对象实际位置的指针,但是有一个前提:实际的对象肯定不是引用。字符串永远是字符串，数组永远是数组。不过多个变量却指向同一对象。JavaScript 基于的就是这样的引用系统。此外，对象可以包含一系列的属性（property），这些属性也都不过是其他对象的引用，一旦该对象的类型改变，则所有的引用也都会改变 123var str = \"hellow world\"; //创造一个实际赋值,在window上声明一个引用指向赋值的地址;var strRef = str; //这是引用str += \"new\"; 这段话的大意是说:上面的str 是 “hellow world”的引用,而 strRef 又是 str 的引用,当 str =”new” 时,实际上str 指向了创建的新的值,而 strRef 还是指向原来值的位置,因此strRef并没有随之而改变;在实际使用中将 strRef 看做str的副本拷贝表面上看也没有上面毛病,新手都是这样过来的,但稍微一思考,为什么strRef也可以调用到String的方法呢?侧面说明了strRef 事实上是个引用,想想在其他语言里面,如果只是拷贝的话,那么我们对strRef的操作就是调用其他对象的方法来进行加工而非调用方法,我们也可以通过这样的方法来验证; 12var str = new String(\"some\");console.log(str); 你在打印的对象中会发现一个隐藏的属性[[PrimitiveValue]]; 而我们实际上需要的并不是一个对象,而是一个值,在函数中是这样写的 12var str = String(\"some\");console.log(str); 在这里我们实际上就是调用了 String 的构造函数,该构造函数直接执行时 return 出了一个属性,但是由于[[PrimitiveValue]]属性被浏览器隐藏起来了([[]]代表浏览器中的隐藏属性),我也只能够猜测大概是这样的 1234function String(str)&#123; return this.PrimitiveValue = str;&#125;var str = String(\"some\"); 但是你又会疑惑,我们平时都是这样声明一个字符串的呀?怎么会调用到构造函数呢? 12var str = \"some\";console.log(str.constructor == String); //true; 看完这句话,又会有新的疑惑,你确定 var 出来值是一个引用?而不是只有对象才有引用吗?请看原话第二段,对象可以包含一系列的属性,这些属性也都不过是其他对象的引用, 而 var 出来的变量实际上也是 window 对象的一个属性,使用引用的好处就在于,所有的引用都指向了原对象,那么也就可以直接调用原对象的方法,而不是使用元对象的方法进行加工.配合链式调用,可以减少变量的创建,进而减少内存的分配; 可以看下方拓展,这样就能够理解:所有=号实际上都是引用符号,而改变其中一个引用的指向,并不会影响另一个引用,非对象的引用每次赋值都是改变引用的指向 而由于原引用一直指向内存,因此原引用并不会被垃圾回收机制所回收:所以代码能够使用链式调用的地方就尽量不要创建新的引用; 拓展:如果说Javascript一切皆对象,那么Javascript都有哪些对象? EMCAJavascript 5.1中的对象本地对象(Native objects): ​ 本地对象有时被称为“全局对象”,”ES规范对象”，因为它们是JavaScript本来可以使用的对象。不要将术语全局对象(global)与作为作用域链的最高级别的“head”全局对象混淆，例如，所有Web浏览器中的“window”对象（head）; 下面列出了用JavaScript预先打包的9个本地对象构造函数：​ Number（）String（）Boolean（）Object（）Array () Function（）Date（）RegExp（）Error JavaScript主要是从这9个对象（以及字符串，数字和布尔值 - 原始值 - 它们的相等性基于值不是参考）构造的。 如果你直接调用构造函数（Number（），String（）和Boolean（）），就返回一个复杂的对象。如果你只是在代码中表示一个数字，字符串或布尔值（原始值，如5，“foo”和true），那么构造函数将返回一个原始值，而不是一个复杂的对象值。 “window”/head对象 而所有 var 声明出来的变量都是 window 的一个属性,我们可以这样论证 123456var a= 2;for(x in window)&#123; if(window[x] === a)&#123; console.log(x) //a &#125;&#125; 如果你想看的更详细也可以 1console.log(this); 你如果你眼力够好会很容易找到其中的Window中的a的; 如果你打开Window对象会发现一个首字母小写window的属性.而点击小window又会打开一个新的window,无穷尽; 网络上,一种模糊的说法是, Window 是主机对象和本地对象交互的地方,个人认为 Window 是存储变量的地方也是dom,事件等方法存储并供浏览器调用的地方; 主机对象(Host objects) ​ 运行JavaScript代码的主机环境（例如web浏览器）通常提供head/window对象（例如web浏览器中的窗口对象），其中语言的本地部分与主机对象（例如web浏览器中的window.location）和用户定义的对象（例如您的写代码在Web浏览器中运行的代码）,简单来说,可以操作浏览器的对象都是属于主机对象.而存在兼容性问题 的代码都是出于主机对象当中; 函数重载(overload)和类型检查​ Java中的函数重载一般是指在实例对象中不满意父级的方法而进行重写覆盖,而书中原文中的重载是通过判断传入参数数量的能力和判断传入参数类型,这一点也是jQuery如此传奇的所在之处,也被后来的Vue.js等框架所吸收利用. JavaScript 中函数重载的两个例子: 例子一: 123456789101112131415161718function sendMessage( msg , obj)&#123; if( arguments.length == 2)&#123; obj.handleMsg(msg); &#125;else&#123; alert( msg); &#125;&#125;//仅用一个参数调用这个函数 - 用 alert 来显示此消息sendMessage( \"Hello, World!\" ); // 弹出 Hello, World!//又或者我们可以传入一个对象sendMessage( \"How are you?\",&#123; handleMag:function(msg)&#123; alert(\"This is a custom message:\"+mag); &#125;&#125;) //弹出This is a custom message:How are you?//这里扩展一下,你就可以发现Vue.js中的new vue(&#123;&#125;)的内部实现其实也类似于这样的,以及commonJs中的配置文件,或者配置Json文档,当做一个对象传入配置器; 例子二: 1234567891011121314// 一个接受任意数量参数并将其转换为数组的函数function makeArray()&#123;//临时使用的数组var arr = [];//遍历传入的每个参数for(var i= 0;i&lt;arguments.length;i++)&#123;arr.push( arguments[i]);&#125;//结果返回数组return arr&#125;//这个再扩展一下,可以对比ES6中的promise或者angular中的$q,和监听者模式; 既然要使用函数重载,那么就需要判断参数传入的类型 判断类型的两种方法:typeof / .constructor, typeof 可以检测非对象类的参数 .constructor可以返回其构造器,是每一个对象都包含的属性 第一种大家已经用的很多了,那么我就只说一下第二种 例子: 123&#123;&#125;.constructor == Object; //true\"str\".constructor == String //turefunction foo()&#123;&#125;;foo.construcot == Function //ture 作用域( scope ):ECMA Javascript 5.1中规定,只有函数级作用域和全局作用域,在浏览器加载脚本时,会将“声明”进行提升,也就是说在其它语言中可能报错的情况下,Js可能只会输出 undefined ; 例如: 12console.log(go);var go = 2; 实际上由于”声明提升”,浏览器将该变量变为了 123var go;console.log(go)go = 2; 对于声明的函数,也有”声明提升” 例如: 1234go();function go()&#123; console.log(\"hellow world!\")&#125; 实际上由于”声明提升”,浏览器将声明的变量写为: 12function go()&#123;console.log(\"hellow world!\")&#125;go(); 需要注意的是: 123456foo();var foo = function()&#123;&#125;;-----------提升------------var foo;foo();foo = function()&#123;&#125;; 该表达式说明了,”声明提升”只会提升等式左边的声明;而右边绝不可能有声明 而函数作用域内的声明也会被提前: 例如: 1234function go()&#123;console.log(a); //undefinedvar a = 2;&#125; 而对于函数作用域内声明过的变量被”声明提升”为: 12345function go()&#123;var a;console.log(a);a = 2;&#125; 对变量的查询方式 : ​ 会先在当前作用域中先进行查看,如果有则使用当前作用域内声明的变量,如果没有则向上一个作用域中去查找,因此一定要注意书写规范,凡是声明变量时在该变量出现在 “=” 左边之前就应该将值初始化 ; 综上几点结论就是:声明提前是浏览器编译Js代码时进行的隐式工作,必须要谨慎对待,凡是声明时便对其赋值 ,可以有效的避免该错误; 拓展:ES6中的作用域规范​ ES6中新增了块级(block)作用域,更符合后端人员的口味,也使得Js代码更规范和健壮,为此新增了let 和 const 来进行块级作用域的声明,例如那个闭包经典问题,在for循环中引用的外全局变量不再是计算过的值,而是被定义时的值,而非执行时的值! ​ 1.let 命令:使用let进行声明的变量将不会提前,无论他在哪里(函数内,全局,块),但是在函数作用域内,虽然不会提升,但是会造成一个“暂时性死区”（temporal dead zone，简称 TDZ）,也就是在(块,函数内)如果有和上一作用域的声明冲突,那么在let声明之前都无法读取到该声明; 也就是说 12345678910111213if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125;//解决的方法就是,如果需要获取到作用域外的某变量时,作用域内不要有重复声明!!//如果有,尽量保持声明写在区域作用域的顶部 ES6规定了块级作用域内也能够声明函数,但该函数无法在块级作用域外使用 由于变量无需提升,那么let将会逐行解析 闭包(closure) 闭包( closure )意味着内层的函数可以引用存在包围它的函数内的变量, 即使外层函数的执行已终止. 闭包,的常用方式, 一、用来封装一些函数，可以减少引用的存在，例如： 12345function gitTime(msg, time)&#123; setTimeout(function()&#123; alert(msg) &#125;,time);&#125; 二、使用闭包来隐藏全局作用域变量 (当然在ES6中解决了这个问题) 123456(function()&#123;var msg = \"Thanks for visiting\"; window.onunload = function()&#123; alert(msg) &#125;&#125;)(); 闭包的经典问题: 假设有10个div. 1234567var div = document.querySelectorAll(\"div\");for(var i = 0;i &lt; 10;i++)&#123; div[i].onclick = function()&#123; console.log(i); &#125;&#125;//答案大家都知道,无论你点哪一个div都会打印10; 书中说函数内拿到的是最终值,但并没有说明原因:我认为这是因为当执行该函数时,执行的位置已经在循环执行完之后,因此如果将函数的调用放在当前即可解决该问题,这也使用了闭包的作用,引用了外层函数的值,当外层函数销毁,内层函数的值不会被销毁因此虽然函数执行完毕,但是i由于有了内部的引用并不会被销毁,当外层函数执行完毕之后,由于i的值被赋予内部进行引用,因此并没有销毁; 123456789var div = document.getElementsByTagName(\"div\");for(var i = 0;i &lt; div.length;i++)&#123;function foo(i)&#123; div[i].onclick = function()&#123; console.log(i); &#125;&#125;foo(i);&#125; 当然,为了节省引用 可以使用匿名函数来进行包装 12345678var div = document.getElementsByTagName(\"div\");for(var i = 0;i &lt; div.length;i++)&#123;(function (i)&#123; div[i].onclick = function()&#123; console.log(i); &#125;&#125;)(i);&#125; 如果觉得晦涩难懂也可以写成这个样子 123456789var div = document.getElementsByTagName(\"div\");for(var i = 0;i &lt; div.length;i++)&#123; div[i].onclick = wrap(i); function wrap(i)&#123; return function ()&#123; console.log(i); &#125; &#125;&#125; 这就是外层函数虽然销毁,但是内层函数对外层函数的引用依然存在 这就是闭包应用的场景,当我们需要延迟执行某一个函数时,而该函数需要引用外部的值,但是该值的计算又提前于函数执行之后,那么就可以使用闭包来解决该问题 上下文 在 JavaScript 中,代码总是有一个上下文对象(代码处在该对象内)。上下问对象是通过 this 变量体现的,这个变量永远指向当前代码所处的对象中。即使是在全局变量中 this 也是指向 widow 对象的。 1.在上下问对象内使用函数并将其上下文对象切换为另一个变量； 123456789var obj = &#123; yes:function()&#123; 此时的this指向的是obj this.var = true; &#125;, no: function()&#123; this.val = false; &#125; &#125; 讲到这,绝大多数新手都会范一个错误; 1234var obj=&#123; this.val = 10, this.name = \"xiaoming\"&#125; 这里注意 var出来的对象,最终调用者其实是window,不要忘记上面有关引用的拓展知识; 因此需要使用函数来切换 this 的指向,至于为什么要这样,我只能说函数本身就有此功能,因为任何函数都可以是构造函数,他都有构造器和函数原型,当他们作为属性时,this 时指向的是自身的对象; 例如: 我们在全局中声明的函数实际上是window对象的一个属性 1234function foo(name)&#123; console.log(this) //打印出window对象 this.name = name&#125; 对于构造函数或者函数中方法我们可以使用call和apply改变上下文 例如: 1234接上个例子:var a = &#123;&#125;;foo.call(a,\"hellow\");console.log(a.name) call在调用时就相当于执行了该函数的方法,并将上下文对象指向了传入的对象, 这样我们可以看到比较经典的例子 12345function foo(name,age)&#123; var newArr = Array.prototype.slice.call(arguments); console.log(newArr);&#125;foo(\"xiaoming\",20); 由于arguments是一个伪数组,并不可以使用Array原型中的方法,对于数组的方法我们没办法使用,就可以使用call方法借调数组原型中的方法,当然一切皆对象,虽然一般没人这样写,但是为了更进一步理解,我们也写了下面的例子: 123456function foo(name)&#123; var name = name; var arr = String.prototype.split.call(name,\"\"); console.log(arr);&#125;foo(\"xiaoming\"); 也就是说凡是其他函数中用this写的操作,我们都可以写成上面这种方式进行调用; 甚至dom对象也可以通过该方法调用,简直就是方便的不要不要的,比如原文中的这个案例: 12345function setColor(color)&#123; this.style.backgroundColor = color;&#125;var body = document.body;setColor.call(body,\"red\"); 当然为了简化和让代码看起来干净,目的明确,原文中写成 1234567function setColor(color)&#123; this.style.backgroundColor = color;&#125;function setBodyColor(color)&#123; setColor.call(document.body,color);&#125;setBodyColor(\"red\"); (那,当变量名无法展示该行代码的功能时,我们就有必要对该行代码进行封装) 还有一种不容易看出来的上下文就是事件中的上下文,事件中的this,是指向调用该事件的元素; 1234var div = document.queryselector(\"div\");div.onclick = function()&#123; this.style.backgroundColor = blue&#125; 面向对象的基础面向对象的基础小节当中主要分为以下几个知识点 1.对象 2.自定义对象的创建 3.静态方法 对象的基础知识大家基本都有理解,那么我们从创建开始讲起: 原文案例: 1234567function User()&#123; this.name = \"go\";&#125;//通过构造器创建一个 User 对象var me = new User();var you = new me.constructor();console.log(me.constructor == you.constructor); 事实上每一个对象的都是通过构造器创建的,这样的创建缺点就是,实例中每一个从构造器继承过来的属性都被隐式的创建了新的引用; 接上一个案例: 1234me=&#123;&#125;;me.name = \"go\";you = &#123;&#125;;you.name = \"go\"; 你的疑惑就是,”我知道了,原来是这样,但是并没有什么问题啊”,问题就在于如果内部有一个方法,那么他也会被拷贝多份,这样也占用了大量的内存; 公共方法(public method)因此除了构造器继承以外,还有原型继承,对于的是原文中的:公共方法 原文案例: 123456789function User(name,age)&#123; this.name = name; this.age = age;&#125;;User.prototype.getName = function()&#123;return this.name&#125;;User.prototype.getAge = function()&#123;return this.age&#125;;var user = new User(\"Bob\",44);alert( user.getName() == \"Bob\");alert( user.getAge() == \"44\"); 这样的好处就是,公共方法中所有实例化的对象都无需创建新的引用便可以使用,可以优化内存 私有方法(private method)原文案例: 12345678910function Classroom( students, teacher)&#123; function disp()&#123; alert(this.names.join(\",\")); &#125; this.students = students; this.teacher = teacher; disp();&#125;var class = new Classroom([\"John\", \"Bob\"], \"Mr.Smith\")class.disp(); //调用失败,因为disp()是一个私有方法; 原文解释: 私有方法和私有变量在保证代码没有冲突的同时,允许你对用户能使用和能看到的内容有更好的控制. 个人理解: ​ 完美报错,错误一:this.names并没有值;是一个undefined; ​ 错误二:占用了class关键字 ​ 这是由于书籍版本的原因,历史原因在此不作讨论了,也不能说人家就错,但是错误一就有点奇怪了,应该再传入一个参数给this.names;应该写为如下 12345678910function Classroom( students, teacher,name)&#123; function disp()&#123; this.names = name console.log(this.names) &#125; this.students = students; this.teacher = teacher; disp();&#125;var class = new Classroom([\"John\", \"Bob\"], \"Mr.Smith\",\"myName\") 这样,在new一个对象时,也可以做一些操作; 特权方法(privileged method) 用来指代那些在查看并处理(对象中)私有变量的同时允许用户以公共方法的方式访问的方法; 原文案例: 123456789function User(name ,age)&#123; var year = (new Date()).getFullYear() - age; this.getYearBorn = function ()&#123; return year; &#125;;&#125;var user = new User(\"Bob\",44);alert(user.getYearBorn() == 1973); //turealert(user.year == null); 本质上,特权方法是动态生成的,因为他们是运行时才添加到对象中的,而不是在代码第一次编译时就已经生成的.虽然这个技巧要比对象的原型继承开销更大,但工功能也更强、和灵活 这里原文中写的很好，就不再解析了； 4.静态方法（static method） 静态方法的实质与任何其他的一般函数没有什么不同,最主要的区别在于,其他函数是以对象的静态属性形式存在的.作为一个属性他们不能在该对象的实例的上下稳中访问,而只属于主对象本身的那个上下文中. 实际上,这样编写代码的唯一有点是保证对象命名空间的整洁 原文例子: 123456User.cloneUser = function(user)&#123; return new User&#123; user.getName(), user.getAge() &#125;&#125; 拓展,这也是 jQuery 中仅仅只使用一个 $ 就可以将所有函数封装的方式,因此在编写功能性强大的框架时,可以使用该方法保持清洁的命名空间; 面向对象的基础小结 开发出专业的 javascript 代码的根本方法之一是,快速、静态地提供与其他代码的接口，同时保证自身的可理解性！ 拓展为了扩展视野,我们来看jQuery中的源码仿写: 12345678910111213141516(function()&#123; var A = function(num)&#123; return A.fn.init(num) &#125;; A.fn = A.prototype=&#123; init:function(num)&#123; this.ele = num; return this; &#125;, print:function()&#123; console.log(this.ele); &#125; &#125; window.$ = A; &#125;)(); $('20').print(); 这是多么有艺术的一段代码啊!如果觉得有些负责也没有关系，在本文最后,我会为大家带来Jquery封装的实现的步骤和推演,让你轻松看懂这段代码的艺术,但现在,我们还需要学习更多知识来做为储备; 创建可重用的代码标准化面向对象的代码原型式继承​ 从原文中仿写的例子: 123456789101112function User()&#123; this.name = \"jhon\";&#125;;User.prototype.getName = function()&#123; return this.name;&#125;;function Person()&#123;&#125;;Person.prototype = new User(); //重点理解!var person = new Person();console.log(person.name); //jhon 这段代码的作用是在以后通过 Person 实例化后的对象,都拥有了 User 的方法,当然后面还讲到了通过该继承方式来进行模拟 Java 语言中的 类继承 的例子,但是ES6中有类似功能,因此在此只作为理解使用; 该例子隐藏了很多个知识点: 1.当创建一个对象实例时,该对象的__proto__属性指向了父级对象 例如: 12345function Person()&#123; this.name = &quot;jhon&quot;&#125;var obj = new Personconsole.log(obj.__proto__); 可以打印person.__proto__来进行查看; 2.当一个对象实例查找一个属性时,会先从自身属性查找,当自身没有时会查找构造函数的构造器,当构造器中也没有时将查找到构造函数的原型 后面的更多写的是基于上面这个例子所写的一些其他人写的仿Class继承的类库,由于ES6实现了很多类似的继承,那么不再拓展,面向对象这一篇章也就算完结了,现在是看这书的第5天,看书工作加消化和书写,也是一场知识与脑力的碰撞,可能写的有点乱,如果有不妥的地方,可以联系我哟.也请如果有转载,请注明出处,谢谢!文章最后的JQ仿写可以参考我的另外一篇文章 !《Jquery仿写》 ### ​ ​ ​","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"移动应用开发","date":"2016-07-22T07:08:32.000Z","path":"2016/07/22/移动应用开发/","text":"#移动应用开发 1、布局种类静态（Static layout）固定死的宽和高 流式布局（Liquid layout）只有一套布局页面元素随着窗口大小而改变，通俗的讲：就是百分比布局，或者用em/rem替换px 响应式（Responsive layout）为不同屏幕定义不同的布局（媒体查询）同时，在每个布局中，应用流式布局，即页面元素宽度随着屏幕调整而自动适配使一个网站能兼容多个终端—而不是为每个终端做一个特定的版本这个概念是为了解决移动互联网浏览而诞生的 2、viewport 视口三种视口layout viewport (布局视口) 浏览器默认的viewport 比屏幕尺寸要宽visual viewport (可视视口) 可以看到的区域大小 随用户的缩放改变ideal viewport (理想视口) 最适合布局的视口，我们需要通过mate标签来得到理想视口 在浏览器上调整窗口大小，通过媒体查询看到网页的响应能力是乎没有任何问题的。 在移动端浏览页面时就出现异常了。 （没有进行Viewport控制的iPhone6上的显示效果） 页面虽然可以看到，但不能自适应手机的屏幕。之所以会有这样的问题，是设备尺寸和Viewport尺寸不一致导致的。为了更好的理解这两个尺寸之间的不同点，下面就简单说说： 设备像素：这个是物理层面的像素数量，比如一台iPhone6，是375x667像素。（注：这里所说的设备像素有两种类型，硬件像素和设备独立像素，不过这个区别与此文无关）； CSS像素：这个是我们在CSS使用过程中的一个抽象的单位，它并没有一个绝对的尺寸，页面上单个CSS像素的大小完全取决于Viewport的大小； Viewport：Viewport决定了页面的像素密度。比如一个宽750px的Viewport，表示屏幕上横向排布了750个CSS像素（Viewport在未缩放的情况下）。 Viewport是”无关设备”的，它不知道也不关心我们的设备到底有多大的屏幕。 可以设置meta标签中的viewport信息，以解决Viewport尺寸不匹配的问题。meta标签的用法如下： 1&lt;meta name=&quot;viewport&quot; content=&quot;key=value, key=value&quot;&gt; 设备像素比http://dpi.lv/ 设备像素(device pixel):设备像素设是物理概念，指的是设备中使用的物理像素。比如iPhone 5的分辨率640 x 1136px。 CSS像素(css pixel):CSS像素是Web编程的概念，指的是CSS样式代码中使用的逻辑像素。在CSS规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px是一个相对单位，相对的是设备像素(device pixel)。 比如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为640 x 1136px，而CSS逻辑像素数为320 x 568px。 设备像素与CSS像素之间的换算是如何产生的呢？这就需要要谈到每英寸像素(pixel per inch)和设备像素比(device pixel ratio)。 每英寸像素(pixel per inch)：ppi，表示每英寸所拥有的像素(pixel)数目，数值越高，代表显示屏能够以越高的密度显示图像。ppi的计算方式可以参考维基百科每英寸像素 设备像素比(device pixel ratio)：以上计算出ppi是为了得到密度分界，获得默认缩放比例，即设备像素比。由上图可知，ppi在120-160之间的手机被归为低密度手机，160-240被归为中密度，240-320被归为高密度，320以上被归为超高密度（Apple给了它一个高大上的名字——Retina）。 获得设备像素比后，便可得知设备像素与CSS像素之间的比例。当这个比率为1:1时，使用1个设备像素显示1个CSS像素。当这个比率为2:1时，使用4个设备像素显示1个CSS像素，当这个比率为3:1时，使用9（3*3）个设备像素显示1个CSS像素。 想要了解主流移动设备的设备像素比(device pixel ratio)可以参考以下两个网站：http://screensiz.es/http://www.devicepixelratio.com/ meta标签content属性的值标签内容中有6个关键字： width height initial-scale minimum-scale maximum-scale user-scalable width= height=width=device-width height=device-height让当前的viewport宽/高度等于设备的宽/高度，也可以可以设置一个固定的值，尽可能不这样使用。height是设置高度使用的，我们很少使用 initial-scaleinitial-scale=1.0设置初始化的缩放比例（0.25 — 10.0，我们设置为1就是没有缩放） maximum-scalemaximum-scale=1.0设置最大缩放比例（0.25 — 10.0） minimum-scaleminimum-scale=1.0设置最小缩放比例（0.25 — 10.0） user-scalableuser-scalable=no是否允许用户缩放值​ yes(默认) / 1​ no / 0​ 如果设置为no，那么minimax-scale和maximum-scale将被忽略，因为不允许缩放 WIDTH 可以用width来设置viewport的宽度，以替代那些不合适的默认宽度。 我们可以给其设定一个固定大小，但设定成device-width更加明智一些，这样可以兼容不同大小的屏幕。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; （在iPhone6上设置width=device-width之后的显示效果） INITIAL-SCALE 在移动设备上，用户有时会需要缩放页面，当页面缩放时，Viewport的像素尺寸也会相应的改变，但CSS尺寸不会变。 比如，在一个400px宽的Viewport中有一个元素，设定width: 100px;，这时该元素就横跨了1/4的屏幕。如果用户把页面放大到两倍大小，这时Viewport宽度变成了200px，但元素仍然宽100个CSS像素。这时这个元素就占了半个屏幕了。 我们可以通过initial-scale来设置CSS像素和Viewport像素之间的比例，通常情况下是1:1。这个参数的设置可以很好的解决width=device-width设置所带来的问题。有些移动设备浏览器会在纵向模式时默认使用设备宽度，当切换到横向模式时页面显示就会不正常。 （在没有设置initial-scale的横向iPhone6上的显示效果） 如图所示，当iPhone处于横向模式时，我们看到的还是宽度小余500px时的页面状态。不过不要慌张，我们可以通过设置initial-scale为1来解决这个问题。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; （在设置了initial-scale的横向iPhone6上的显示效果） USER-SCALABLE，MAXIMUM-SCALE以及MINIMUM-SCALE 这几个参数用来控制页面的缩放能力。 Maximum-scale：这个是用户可以缩放页面的最大比例。比如说设置为1，用户就无法缩放页面。假如设置为2，用户就可以把页面放大到1个CSS像素等于2个Viewport像素的大小； Minimum-scale：这个是用户可以缩放页面的最小比例。假如设置为2，页面的最小比例就是原比例的两倍，并且无法缩小到原始比例； User-scalable：如果设置了user-scalable=no，用户将无法对页面进行缩放。 由于这几个参数限制了用户对页面的操作，通常不建议使用它们。 用CSS来控制Viewport虽然现在很多人都在用viewport，但其实viewport并不是HTML5标准中的正式成员。W3C目前正在研究将viewport以@viewport规则的形式加入到CSS当中，@viewport规则与viewport标签有异曲同工之妙，只是将用于布局的viewport归还给CSS，现在已经有部分开发者在尝试@viewport了。 12345678910@viewport &#123; zoom: 1.0; /* same as initial-scale=1 */ width: device-width;&#125;/* Vendor specific prefixes */@-ms-viewport @-webkit-viewport @-moz-viewport @-o-viewport 在@viewport正式发布之前，还是先继续使用viewport标签吧，如果有兴趣的话可以尝试一下测试版的@viewport。 3、媒体查询媒体查询让CSS可以更精确作用于不同的设备类型和同一设备的不同条件（如屏幕尺寸） Media Type 设备类型常见的有screen(电脑显示屏)，all(所有设备)，print(打印用纸或打印预览图)等 Media Query 媒体特性可以看成Media Type(判断条件) + CSS(符合条件的样式规则)，常用的设备特性有width，height，device-width(设备屏幕的输出宽度)等大部分媒体特性都接收min和max前缀，用于表达：大于或等于 和 小于或等于 使用方法媒体类型 and （媒体特性）可以多个媒体特性一起使用，用关键字and连接如果没有指出媒体类型，则默认为all可以使用多条语句，将同一样式应用到不同的媒体以特性中，语句用“，”隔开 not关键字排除符合表达式的设备如@media not print and (min-width: 900px){}，样式将被使用在除打印设备和屏幕宽度大于900的所有设备上 only关键字可以让支持media type 而不支持媒体查询的浏览器忽略掉这段代码 实现方式1. link标签设置通过link标签的media属性设置 2. @mediacss样式表中内嵌@media，css3新特性，媒体查询: @media screen and (max-width: 700px) and (min-width: 500px) {​ css样式} 123456789101112131415161718192021222324/* min-width：屏幕最小宽度是1200px（大于大等于1200px）*/@media only screen and (min-width: 1200px) &#123; &#125;/* 最小是992，最大是1199 （大于等于801px并且小于等于1199px） */@media only screen and (min-width: 801px) and (max-width: 1199px) &#123; body&#123; background-color: red; &#125;&#125;/* 注意：801 到 991 之间 没有条件的话，就用默认样式 */@media only screen and (min-width: 600px) and (max-width: 800px) &#123; body&#123; background-color: blue; &#125;&#125;@media only screen and (max-width: 599px) &#123; body&#123; background-color: yellow; &#125;&#125; 还可以设置设备像素比，可用于大屏幕尺寸适应: http://blog.madewithdrew.com/post/working-with-dppx/ 12345678@media only screen and (-webkit-min-device-pixel-ratio: 1.3), only screen and (min--moz-device-pixel-ratio: 1.3), only screen and (-o-min-device-pixel-ratio: 1.3 / 1), only screen and (min-resolution: 1.3dppx), only screen and (min-resolution: 125dpi) &#123; &#125; 4、图片自适应:处理图片缩放的方法 简单的解决方法可以使用百分比，会放大或者缩小图片。那么可以尝试给图片指定的最大宽度为百分比。假如图片超过了，就缩小。假如图片小了，就原尺寸输出。 1img &#123; width: auto; max-width: 100%; &#125; 用::before和::after伪元素 +content 属性来动态显示一些内容或者做其它很酷的事情，在 css3 中，任何元素都可以使用 content 属性了，这个方法就是结合 css3 的 attr 属性和 HTML 自定义属性的功能： HTML 结构： 1234&lt;img src=&quot;image.jpg&quot; data-src-600px=&quot;image-600px.jpg&quot; data-src-800px=&quot;image-800px.jpg&quot; alt=&quot;&quot;&gt; CSS 控制： 1234567891011@media (min-device-width:600px) &#123; img[data-src-600px] &#123; content: attr(data-src-600px, url); &#125;&#125;@media (min-device-width:800px) &#123; img[data-src-800px] &#123; content: attr(data-src-800px, url); &#125;&#125; 5、em、rem布局的实现百分比尺寸百分比​ width: 20%;位置百分比​ top: 50%;保留小数点后5位​ 3.12345% em相对单位，1em就是1个字符的大小 ，即font-size的大小font-size是可继承得，如果元素没有font-size，em会继承父级元素的字体大小 remfont size of the root elementCSS3的单位相对于根元素的font-size，即html标签 http://www.w3cplus.com/css/when-to-use-em-vs-rem.html​​","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"响应式布局","slug":"响应式布局","permalink":"http://yoursite.com/tags/响应式布局/"}]},{"title":"流式布局","date":"2015-09-12T14:08:47.000Z","path":"2015/09/12/流式布局/","text":"流式布局网页布局分类:网页布局（layout）是CSS的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。 网络布局分类主要有如下： 静态布局（Static Layout）即传统Web设计，对于PC设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分； 对于移动设备，单独设计一个布局，使用不同的域名如wap.或m.。 自适应布局（Adaptive Layout）自适应布局（Adaptive）的特点是分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。你可以把自适应布局看作是静态布局的一个系列。 浮动布局(Float Layout)​ 通过Float属性来进行浮动布局，是基于CSS的现代Web设计用到的主要功能之一，可以用它来创建多级的网页布局，从无序列表创建导航工具条，不是用table而创建类似表格的对其方式等。​ 为使元素浮动到左边或者右边，并使后面的文本环绕它，可使用float属性，float属性的取值是：none(不浮动)，left(向左浮动)，right(向右浮动)。​ 使用float属性后，浮动的元素从正常文档流中脱离出来，同时对布局中的其他元素造成一定的影响。浮动可以应用于任何元素。 定位布局(Position Layout)通过CSS Position属性来设置相对定位和绝对定位 定位标签：position 包含属性：relative（相对） absolute（绝对） 1.position:relative; 如果对一个元素进行相对定位，首先它将出现在它所在的位置上。然后通过设置垂直或水平位置，让这个元素”相对于”它的原始起点进行移动。（再一点，相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其他框） 2.position:absolute; 表示绝对定位，位置将依据浏览器左上角开始计算。 绝对定位使元素脱离文档流，因此不占据空间。普通文档流中元素的布局就像绝对定位的元素不存在时一样。（因为绝对定位的框与文档流无关，所以它们可以覆盖页面上的其他元素并可以通过z-index来控制它层级次序。z-index的值越高，它显示的越在上层。） 3.父容器使用相对定位，子元素使用绝对定位后，这样子元素的位置不再相对于浏览器左上角，而是相对于父窗口左上角 4.相对定位和绝对定位需要配合top、right、bottom、left使用来定位具体位置，这四个属性只有在该元素使用定位后才生效，其它情况下无效。另外这四个属性同时只能使用相邻的两个，不能即使用上又使用下，或即使用左，又使用右。 流式布局（Liquid/Flow Layout）流式布局（Liquid/Flow）的特点（也叫”Fluid”) 是页面元素的宽度按照屏幕进行适配调整，主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。 可以使用CSS中的flex属性很快速灵活地实现流式布局 响应式布局（Responsive Layout）分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。 2、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。Flex布局将成为未来布局的首选方案。 任何一个容器都可以指定为Flex布局。 1234&gt; .box&#123;&gt; display: flex;&gt; &#125;&gt; 行内元素也可以使用Flex布局。 1234&gt; .box&#123;&gt; display: inline-flex;&gt; &#125;&gt; Webkit内核的浏览器，必须加上-webkit前缀。 12345&gt; .box&#123;&gt; display: -webkit-flex; /* Safari Chrome*/&gt; display: flex;&gt; &#125;&gt; 注意，容器赋予了display: flex属性，将会有以下特点： 无法设置浮动，float属性失效 列表的样式会被清除，clear属性失效 无法使用vertical-align设置垂直对齐方式 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴： 水平的主轴（main axis）和垂直的交叉轴（cross axis）。 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end； 交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性(作用于父级上)以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 12345&gt; .box &#123;&gt; flex-direction: row | row-reverse | column | column-reverse;&gt; &#125;&gt;&gt; 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 12345&gt; .box&#123;&gt; flex-wrap: nowrap | wrap | wrap-reverse;&gt; &#125;&gt;&gt; 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 12345&gt; .box &#123;&gt; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&gt; &#125;&gt;&gt; 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 12345&gt; .box &#123;&gt; justify-content: flex-start | flex-end | center | space-between | space-around;&gt; &#125;&gt;&gt; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 12345&gt; .box &#123;&gt; align-items: flex-start | flex-end | center | baseline | stretch;&gt; &#125;&gt;&gt; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 12345&gt; .box &#123;&gt; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&gt; &#125;&gt;&gt; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性(作用于子级元素上)以下6个属性设置在项目(子元素)上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 12345&gt; .item &#123;&gt; order: &lt;integer&gt;;&gt; &#125;&gt;&gt; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 12345&gt; .item &#123;&gt; flex-grow: &lt;number&gt;; /* default 0 */&gt; &#125;&gt;&gt; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 12345&gt; .item &#123;&gt; flex-shrink: &lt;number&gt;; /* default 1 */&gt; &#125;&gt;&gt; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 12345&gt; .item &#123;&gt; flex-basis: &lt;length&gt; | auto; /* default auto */&gt; &#125;&gt;&gt; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 12345&gt; .item &#123;&gt; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&gt; &#125;&gt;&gt; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 12345&gt; .item &#123;&gt; align-self: auto | flex-start | flex-end | center | baseline | stretch;&gt; &#125;&gt;&gt; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","tags":[{"name":"布局","slug":"布局","permalink":"http://yoursite.com/tags/布局/"}]},{"title":"CSS/CSS3常用样式小结","date":"2015-08-28T12:00:28.000Z","path":"2015/08/28/CSS&CSS3常用样式小结/","text":"CSS/CSS3常用样式小结 1.文本显示问题强制文本单行显示： 1white-space:nowrap; 多行文本最后省略号 1display: -webkit-box; -webkit-line-clamp:2; overflow: hidden; -webkit-box-orient: vertical; text-overflow: ellipsis; 2.设置溢出文本显示为省略标记：1text-overflow:ellipsis; (注：text-overflow:clip | ellipsis | ellipsis-word;（css3新增加的）其中clip表示直接裁切溢出的文本；值ellipsis表示文本溢出时，显示省略标记(…)，省略标记代替最后一个字符；值ellipsis-word表示文本溢出时，也是显示省略标记(…),不同的是，省略标记代替的是最后一个词)例：想让一段文字在固定宽度在一行显示，最后一个字符为省略标记(…)，css样式如下 1white-space:nowrap;text-overflow:ellipsis;overflow:hidden; 3.a标签的中的图片有虚线框的问题例如一段代码：1&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;img src=&quot;images/suba.gif&quot;&gt;&lt;/a&gt; 当点击a标签里面的图片的时候，有虚线框，IE中图片还有边框，如何解决？解决办法： 123a&#123;outline:none;&#125;//主要是针对火狐等浏览器，但IE不行img&#123;border:0;&#125;a:active&#123;noOutline:expression(this.onFocus=this.blur());&#125;//解决IE6，IE7中的虚线框。 对于a标签来说，一般简单的解决办法是：在a标签里加入js控制，当a标签被聚焦时，强制取消焦点，这时候a标签自然不会有虚线框。 1&lt;a href=&quot;#&quot;onfocus=&quot;this.blur();&quot;&gt;测试&lt;/a&gt; 但是当连接太多的时候，一个一个的加这段代码不实用 4.html中两张图横向回车导致间隙,怎么才能去除成为无间隙？例如：div 宽300px ; img 宽100px; border:0px; 1&lt;div&gt;&lt;img /&gt;&lt;img /&gt;&lt;img /&gt;&lt;/div&gt; //上面情况刚好显示三张图 12345&lt;div&gt; &lt;img /&gt; &lt;img /&gt; &lt;img /&gt;&lt;/div&gt; 这种情况就无法在横向显示三张图，因为回车导致两图间有间隙。解决办法就是让图片浮动。 5.css ie6、ie7中overflow:hidden无效解决办法产生原因：当父元素的直接子元素或者下级子元素的样式拥有position:relative属性时，父元素的overflow:hidden 属性就会失效。解决办法：我们在IE 6、7 内发现子元素会超出父元素设定的高度，即使父元素设置了overflow:hidden。解决这个bug很简单，在父元素中使用 position:relative; 即可解决该bug 6.表格语法...表格位置,置左...表格位置,置中...背景图片的URL=就是路径网址...设定表格边框大小(使用数字)...设定表格的背景颜色...设定表格边框的颜色...设定表格暗边框的颜色...设定表格亮边框的颜色...指定内容与格线之间的间距(使用数字)...指定格线与格线之间的距离(使用数字)...指定表格的栏数...设定表格外框线的显示方式...指定表格的宽度大小(使用数字)...指定表格的高度大小(使用数字)…指定储存格合并栏的栏数(使用数字)…指定储存格合并列的列数(使用数字) 7.CSS text-transformtext-transform 属性控制文本的大小写。 none 默认。定义带有小写字母和大写字母的标准的文本。capitalize 文本中的每个单词以大写字母开头。uppercase 定义仅有大写字母。lowercase 定义无大写字母，仅有小写字母。inherit 规定应该从父元素继承 text-transform 属性的值。 8. letter-spacingletter-spacing 属性增加或减少字符间的空白（字符间距）。例如： letter-spacing: 2px; 9.textarea去掉右侧滚动条，去掉右下角拖拽代码： 10.css中透明度兼容代码filter: alpha(opacity=80);opacity:0.8; 11.根据input的type来控制css样式a.用css中的type选择器 1input[type=&quot;text&quot;]&#123; background-color:#FFC;&#125; b.用css的expression判断表达式 1input&#123; background-color:expression(this.type==&quot;text&quot;?&apos;#FFC&apos;:&apos;&apos;);&#125; c.用javascript脚本实现(觉得没必要，省略…) 12：text-stroke[ text-stroke-width ]：设置或检索对象中的文字的描边厚度 [ text-stroke-color ]：设置或检索对象中的文字的描边颜色text-stroke(文本描边)和text-fill-color(文本填充色)注意点：目前这两个属性只有webkit内核的Safari和Chrome支持，例如： -webkit-text-stroke: 3.3px #2A75BF;text-fill-color：颜色值，和color属性差不多都是文字的样式；同时使用text-fill-color和color属性，text-fill-color将覆盖color属性的颜色值；text-fill-color可以使用透明值，即：text-fill-color：transparent 13：text-shadow1text-shadow:0px 0px 0px #333333; 属性值依次：水平方向位移（支持负值）、垂直方向位移（支持负值）、模糊半径、阴影颜色text-shadow对同一个text，可设置多个阴影，与box-shadow类似，使用逗号”,”分割，前一个设置效果在后一个设置效果之上。box-shadow 参考：http://www.cnblogs.com/lhb25/… 14.css3设置字体123456789101112&lt;style&gt; @font-face&#123;font-family: myFirstFont;src: url(&apos;Sansation_Light.ttf&apos;), url(&apos;Sansation_Light.eot&apos;); /* IE9+ */&#125;div&#123;font-family:myFirstFont;&#125;&lt;/style&gt; 15. css强制性换行1234&#123;word-break:break-all; /*支持IE，chrome，FF不支持*/word-wrap:break-word;/*支持IE，chrome，FF*/&#125; 16.CSS :first-child 选择器,:last-child选择器,nth-child(IE7,8无效，不识别):nth-child(2)选取第几个标签，“2可以是你想要的数字”:nth-child(2n)选取偶数标签，2n也可以是even:nth-child(2n-1)选取奇数标签，2n-1可以是odd:nth-child(3n+1)自定义选取标签，3n+1表示“隔二取一” 17. css3实现背景颜色渐变12345background:-webkit-linear-gradient(top,#FFF,#cb1919);background:-o-linear-gradient(top,#FFF,#cb1919);background:-ms-linear-gradient(top,#FFF,#cb1919);background:-moz-linear-gradient(top,#FFF,#cb1919);background:linear-gradient(top,#FFF,#cb1919); 第一个参数：设置渐变的起始位置第二个参数：设置起始位置的颜色第三个参数：设置终止位置的颜色 IE 浏览器IE浏览器实现渐变只能使用IE自己的滤镜去实现filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=＃00ffff,endColorstr=＃9fffff,grandientType=1);第一个参数：渐变起始位置的颜色第二个参数：渐变终止位置的颜色第三个参数：渐变的类型0 代表竖向渐变 1 代表横向渐变 18.css3的RGB颜色和HSL颜色， IE8不识别rgba写法其中RGB颜色的原理是通过定义不同的红绿蓝色值来组成一个颜色。color:rgb(254,2,8);其中HSL是通过色相、饱和度、亮度模式来申明颜色的。color:hsl(359,99%,40%);如果需要设置透明背景 则可以用到他们： 12background-color:hsla(0,0%,100%,0.8);background-color:rgba(255,255,255,0.8); 不使用opacity的原因是：opacity使里面的元素也透明了，而上面的不会。background-color:rgba(0,0,0,0.5)，此写法解决opacity带来的元素也透明问题，单IE8低版本浏览器不支持。 19.初始化em，u的斜体1em,u&#123;font-style: normal;&#125; 20.取消手机页面点击a中图片出现的虚线框问题123-webkit-tap-highlight-color: transparent;-webkit-touch-callout: none;-webkit-user-select: none; 21.媒体查询功能:一般写法： 12345@media screen and (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125; 应该有人会发现上面这段代码里面有个screen，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略screen,因为你的网站可能不需要考虑用户去打印时，你可以直接这样写： 12345@media (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125; 其中css2的媒体查询：`` 我们想知道移动设备是不是纵向放置的显示屏，可以这样写： 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (orientation:portrait)&quot; href=&quot;style.css&quot;&gt; 我们把第一段的代码也用CSS2来实现，让它一样可以让页面宽度小于960的执行指定的样式文件： 但是上面这个方法，最大的弊端是他会增加页面http的请求次数，增加了页面负担，我们用CSS3把样式都写在一个文件里面才是最佳的方法。 下面的写法是实现尺寸等于480px： 123@media (max-device-height:480px) and (-webkit-min-device-pixel-ratio:2)&#123;//自己添加的样式&#125; 其中对于-webkit-min-device-pixel-ratio作如下解释： 123456789101112131415161718192021222324252627282930313233-webkit-min-device-pixel-ratio为1.01. 所有非Retina的Mac2. 所有非Retina的iOS设备3. Acer Iconia A500 4. Samsung Galaxy Tab 10.15. Samsung Galaxy S -webkit-min-device-pixel-ratio为1.31. Google Nexus 7-webkit-min-device-pixel-ratio为1.51. Google Nexus S 2. Samsung Galaxy S II 3. HTC Desire4. HTC Desire HD5. HTC Incredible S 6. HTC Velocity7. HTC Sensation -webkit-min-device-pixel-ratio为2.01. iPhone 42. iPhone 4S3. iPhone 54. iPad (3rd generation)5. iPad 46. 所有Retina displays 的MAC7. Google Galaxy Nexus8. Google Nexus 49. Google Nexus 1010. Samsung Galaxy S III11. Samsung Galaxy Note II12. Sony Xperia S13. HTC One X 22.CSS美化Placeholder提示信息的样式兼容：12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:#EEEEEE;&#125; 手机对Placeholder提示信息都基本带有默认的样式，要修改其样式需要这样添加：/ WebKit browsers /::-webkit-input-placeholder {color: #777;}/ Mozilla Firefox 4 to 18 /:-moz-placeholder {color: #777;opacity: 1;}/ Mozilla Firefox 19+ /::-moz-placeholder {color: #777;opacity: 1;}/ Internet Explorer 10+ /:-ms-input-placeholder {color: #777;} 谷歌浏览器(Webkit): ::-webkit-input-placeholder pseudo-element; IE10: :-ms-input-placeholder pseudo-class; 火狐浏览器(Gecko18-): :-moz-placeholder pseudo-class; 火狐浏览器(Gecko19+): ::-moz-placeholder pseudo-element; Opera(Presto): 无。 23.清除IOS系统手机对input框的默认样式：1-webkit-appearance:none; 24.取消点击a标签出现的高亮：-webkit-tap-highlight-color:rgba(0, 0, 0, 0); /* 取消链接高亮 */ 25.开发移动端页面时候，经常会设置滚动条的默认样式123456789101112131415161718- /* 设置滚动条的样式 */ - ::-webkit-scrollbar &#123; - width:12px; - &#125; - /* 滚动槽 */ - ::-webkit-scrollbar-track &#123; - -webkit-box-shadow:inset006pxrgba(0,0,0,0.3); - border-radius:10px; - &#125; - /* 滚动条滑块 */ - ::-webkit-scrollbar-thumb &#123; - border-radius:10px; - background:rgba(0,0,0,0.1); - -webkit-box-shadow:inset006pxrgba(0,0,0,0.5); - &#125; - ::-webkit-scrollbar-thumb:window-inactive &#123; - background:rgba(255,0,0,0.4); - &#125; 26.为移动端页面中滑动滚动条的时候，添加惯性效果的方法首先设置： 1div&#123;height:100%;overflow-y:auto;&#125; 但是实际在 iPhone 上测试时，发现 Safari（也包括很多 iOS App 内置浏览器使用的 UIWebView）竟然完全禁用掉了著名的「惯性滚动」效果。但解决方法是有的，令人吃惊的是还非常简单：只有一条 CSS 属性即可解决问题： 1-webkit-overflow-scrolling:touch; 有的同学添加了这一条属性后遇到了向下滑动后页面变成空白的问题，实际上可以通过一条 CSS 属性把页面加载到内存来解决： 1-webkit-transform:translate3d(0,0,0); 注：如果设置了-webkit-overflow-scrolling: touch;那么在IOS系统下对于改变滚动条的默认样式将失效，即上面一条所述。 27.样式实现三角形：123456789position:absolute;left:50%;bottom:0;margin-left:-10px;width:0;height:0; border-width:10px;border-style:solid dashed dashed dashed;border-color:transparent transparent #71151c transparent; 28.移动端实现控制文本行数12345display: -webkit-box;-webkit-line-clamp: 4;overflow: hidden;text-overflow: ellipsis;-webkit-box-orient: vertical; 29. css3水平垂直居中1234567display: box; display: -webkit-box; display: -moz-box; -webkit-box-pack:center; -moz-box-pack:center; -webkit-box-align:center; -moz-box-align:center; 30.Css–input输入框点击时去掉外框outline:medium;(chrome)1outline:medium; 31.移动端字体/ 移动端定义字体的代码 / 1body&#123;font-family:Helvetica;&#125; 32.禁止ios 长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片1.css&#123;-webkit-touch-callout: none&#125; 33.禁止ios和android用户选中文字1.css&#123;-webkit-user-select:none&#125; 34.打电话发短信，发邮件的怎么实现打电话：[打电话给:0755-10086](tel:0755-10086)发短信：winphone系统无效，[发短信给: 10086](sms:10086)发邮件：[10086@qq.com](mailTo:10086@qq.com) 35.css3属性 -webkit-filter(改变模糊度 亮度 透明度等方法) -webkit-filter是css3的一个属性，Webkit率先支持了这几个功能，感觉效果很不错。下面咱们就学习一下filter这个属性吧。现在规范中支持的效果有： 12345678910- grayscale 灰度 值为0-1之间的小数 - sepia 褐色 值为0-1之间的小数- saturate 饱和度 值为num- hue-rotate 色相旋转 值为angle- invert 反色 值为0-1之间的小数- opacity 透明度 值为0-1之间的小数- brightness 亮度 值为0-1之间的小数- contrast 对比度 值为num- blur 模糊 值为length- drop-shadow 阴影 用法是标准的CSS写法，如： 1-webkit-filter: blur(2px); 使用方法：（配合动画使用） 123456789101112131415161718.jaguar-con-show img.jaguar-con-imglast&#123; -webkit-transition: all 0.3s ease-in-out; -moz-transition: all 0.3s ease-in-out; -o-transition: all 0.3s ease-in-out; -ms-transition: all 0.3s ease-in-out; transition: all 0.3s ease-in-out; &#125;.jaguar-con-show img.jaguar-con-imglast&#123; -webkit-filter: blur(3px) brightness(.6); -moz-filter: blur(3px) brightness(.6); -o-filter: blur(3px) brightness(.6); -ms-filter: blur(3px) brightness(.6); filter: blur(3px) brightness(.5); -webkit-transform:scale(1.1,1.1); -moz-transform:scale(1.1,1.1); /*border: 3px solid #000;*/&#125; 36.CSS pointer-eventsPointer-events原本来源于SVG，目前在很多浏览器中已经得到体现。不过，要让任何HTML元素生效还得借助于一点点css。该属性称之为pointer-events，基本上可以将它设置为auto，这是正常的行为，而“none”是一个有趣的属性。如果你已经设置一个元素的css属性为pointer-events: none。它将不会捕获任何click事件，而是让事件穿过该元素到达下面的元素.Firefox 3.6+和chrome 2.0+ 以及safari 4.0+都支持这个CSS3属性，IE6/7/8/9都不支持，Opera在SVG中支持该属性但是HTML中不支持。 37.取消手机点击屏幕时，会出现的灰块1html,body&#123;-webkit-text-size-adjust: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125; 38.样式改变单词的大小写首字母大写：text-transform:capitalize全部大写：text-transform:uppercase全部小写：text-transform:lowercasecase 1234&lt;span style=&quot;text-transform:capitalize;&quot; &gt;this is a test!!!&lt;/span&gt;首字母大写&lt;input type=&quot;text&quot; style=&quot;text-transform:capitalize;&quot;&gt;全部大写&lt;input type=&quot;text&quot; style=&quot;text-transform:uppercase;&quot;&gt;全部小写&lt;input type=&quot;text&quot; style=&quot;text-transform:lowercasecase;&quot;&gt; 39.设置表格中的td宽度固定table-layout:fixed1234table &#123; table-layout:fixed; &#125; table-layout可能的值如下：automatic：默认。列宽度由单元格内容设定。fixed：列宽由表格宽度和列宽度设定。inherit：规定应该从父元素继承 table-layout 属性的值。 40.合并表格边框border-collapse:collapse1234table &#123; border-collapse:collapse; &#125; border-collapse可能的值如下：separate：默认值。边框会被分开。不会忽略 border-spacing 和 empty-cells 属性。collapse：如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性。inherit：规定应该从父元素继承 border-collapse 属性的值。例如： 123456789table &#123; border-collapse:collapse; &#125;table, td, th &#123; border:1px solid black; &#125; 41.不允许用户选中文本user-select：nonehtml代码： 1&lt;div class=&quot;test&quot; onselectstart=&quot;return false;&quot; unselectable=&quot;on&quot;&gt;选择我试试，你会发现怎么也选择不到我，哈哈哈哈&lt;/div&gt; css代码： 1.test&#123;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;&#125; 代码解释： IE6-9不支持该属性，但支持使用标签属性 onselectstart=”return false;” 来达到 user-select:none 的效果；Safari和Chrome也支持该标签属性； 直到Opera12.5仍然不支持该属性，但和IE6-9一样，也支持使用私有的标签属性 unselectable=”on” 来达到 user-select:none 的效果；unselectable 的另一个值是 off； 除Chrome和Safari外，在其它浏览器中，如果将文本设置为 -ms-user-select:none;，则用户将无法在该文本块中开始选择文本。不过，如果用户在页面的其他区域开始选择文本，则用户仍然可以继续选择将文本设置为-ms-user-select:none; 的区域文本； 对应的脚本特性为userSelect。 42.让内容平均分配html代码： 12345&lt;nav&gt; &lt;a href=&quot;#&quot;&gt;a&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;b&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;c&lt;/a&gt;&lt;/nav&gt; css代码： 12nav&#123;display:-webkit-flex;display:flex;&#125;a&#123;-webkit-flex:1;flex:1;&#125; 43.html title属性内容换行方法a.直接填写title内容时候“回车键”换行b.使用html title换行代码使用代码换行共两种代码，均可实现html标签内title内容显示时换行。换行代码符合分别为：“`”和“” “”拼写：&amp;（and符号，键盘数字键7一起&amp;）+ #（井号）+ 10（阿拉伯数字十）+ ;（小写分号） “`”拼写：&amp;（and符号，键盘数字键7一起&amp;）+ #（井号）+ 13（阿拉伯数字十三）+ ;（小写分号）以上符合数字输入均必须英文半角模式输入。使用时候，在需要换行地方任选一种（组）换行符号代码即可。 44.移动端定宽布局，安卓上文字变大了解决办法如： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=750,user-scalable=no,target-densitydpi=device-dpi&quot; /&gt; 那么解决办法：给文字区外面的div设最大高度100% 45.怎样取消点击a标签后，出现的虚线框呢1a:focus &#123; outline:none; -moz-outline:none;&#125; 46.微信会自动把公众号网页上的电话号码变成蓝色?1&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt; 47.box-shadow为了兼容各主流浏览器并支持这些主流浏览器的较低版本，在基于Webkit的Chrome和Safari等浏览器上使用box-shadow属性时，我们需要将属性的名称写成-webkit-box-shadow的形式。Firefox浏览器则需要写成-moz-box-shadow的形式。全面的写法： 123456.box-shadow-6&#123; box-shadow:-10px 0 10px red, /*左边阴影*/ 10px 0 10px yellow, /*右边阴影*/ 0 -10px 10px blue, /*顶部阴影*/ 0 10px 10px green; /*底边阴影*/ &#125; 参考地址：http://blog.csdn.net/freshlov… 48.网页字体设置@font-face{ 123456font-family:&apos;YourWebFontName&apos;;src:url(&apos;YourWebFontName.eot&apos;); /* IE9 Compat Modes */src:url(&apos;YourWebFontName.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;YourWebFontName.woff&apos;) format(&apos;woff&apos;), /* Modern Browsers */ url(&apos;YourWebFontName.ttf&apos;) format(&apos;truetype&apos;), /* Safari, Android, iOS */ url(&apos;YourWebFontName.svg#YourWebFontName&apos;) format(&apos;svg&apos;); /* Legacy iOS */&#125; 参考地址：https://segmentfault.com/a/11…","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"小结","slug":"小结","permalink":"http://yoursite.com/tags/小结/"}]},{"title":"Chrome 控制台使用指南","date":"2015-06-22T07:08:32.000Z","path":"2015/06/22/Chrome console使用指南/","text":"Chrome 控制台使用指南前言​ Chrome浏览器我想是每一个前端必用工具之一吧，一部分原因是它速度快，体积不大，支持的新特性也比其它浏览器多，还有一部分我想就是因为它的控制台功能强大了吧，说它是神器一点也不过分，很方便。但其实很多开发者并没有用出控制台的精髓，只是使用简单的console.log();其实控制台功能远远不止这么简单哦。 console.clearconsole.clear();清空控制台 console.log家族先简单介绍一下chrome的控制台，打开chrome浏览器，按f12就可以轻松的打开控制台 我们主要看看console.log的几个兄弟： 12345671.console.log (&apos;普通信息&apos;)2.console.info (&apos;提示性信息&apos;)3.console.error (&apos;错误信息&apos;)4.console.warn (&apos;警示信息&apos;) ​ 控制台 大家都会用log，但很少有人能够很好地利用console.error，console.warn 等将输出到控制台的信息进行分类整理。他们功能区别不大，意义在于将输出到控制台的信息进行归类，或者说让它们更语义化。 如果再配合console.group 与console.groupEnd，可以将这种分类管理的思想发挥到极致。这适合于在开发一个规模很大模块很多很复杂的Web APP时，将各自的log信息分组到以各自命名空间为名称的组里面。 1234567console.group(&quot;app.bundle&quot;);console.warn(&quot;来自bundle模块的警告信息1&quot;);console.warn(&quot;来自bundle模块的警告信息2&quot;);console.groupEnd();console.group(&quot;app.bundle&quot;);console.log(&quot;来自bundle模块的信息1&quot;);console.log(&quot;来自bundle模块的信息2&quot;);console.groupEnd(); 这样的控制台信息看上去就一目了然了，就不用再为了找这是属于那一行代码输出的再翻一遍源码了。 另外，console.log家族还给我们提供了一个的API：第一个参数可以带一些格式化指令，比如%c,\\n;看下面这个炫酷的效果： 1console.log(&apos;%chello world&apos;, &apos;background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;&apos;); 另外，console.log() 接收不定参数，参数间用逗号分隔，最终会输出会将它们以空白字符连接。 table(data[, columns])将对象数据以表格形式显示，columns为可选的列标题。 12345var names =&#123; 0:&#123;firsName:&quot;John&quot;,LastName:&quot;Smith&quot;&#125; 1:&#123;firsName:&quot;Jane&quot;,LastName:&quot;Doe&quot;&#125;&#125;;console.table(data.content); 有的时候后端传回来一大串数据，是不是觉得直接console.log或是通过抓包工具查看都会让人晕头转向呢，这个时候正事console.table发挥作用的时候了，以表格的形式呈现数据，自然一目了然。 console.assert12var isDebug=false;console.assert(isDebug,&apos;开发中的log信息。。。&apos;); 当你想代码满足某些条件时才输出信息到控制台，那么你大可不必写if或者三元表达式来达到目的，cosole.assert便是这样场景下一种很好的工具，它会先对传入的表达式进行断言，只有表达式为假时才输出相应信息到控制台。 console.count除了条件输出的场景，还有常见的场景是计数。 当你想统计某段代码执行了多少次时也大可不必自己去写相关逻辑，内置的console.count可以很地胜任这样的任务. $上面的$_需要领悟其奥义才能使用得当，而$0~$4则代表了最近5个你选择过的DOM节点。 什么意思呢？在页面右击选择审查元素，然后在弹出来的DOM结点树上面随便点选，这些被点过的节点会被记录下来，而$0会返回最近一次点选的DOM结点，以此类推，$1返回的是上上次点选的DOM节点，最多保存了5个，如果不够5个，则返回undefined。 另外值得一赞的是，Chrome 控制台中原生支持类jQuery的选择器，也就是说你可以用$加上熟悉的css选择器来选择DOM节点，多么滴熟悉。 12$(&apos;body&apos;);$$(&apos;div&apos;); $x(path)将所匹配的节点放在一个数组里返回 12$x(&quot;//p&quot;);$x(&quot;//p[a]&quot;); $x(&quot;//p&quot;)匹配所有的p节点，$x(&quot;//p[a]&quot;);匹配所有子节点包含a的p节点","tags":[{"name":"浏览器工具","slug":"浏览器工具","permalink":"http://yoursite.com/tags/浏览器工具/"}]},{"title":"Emmet指令指南","date":"2015-06-20T04:01:32.000Z","path":"2015/06/20/Emmet/","text":"Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具: 基本上，大多数的文本编辑器都会允许你存储和重用一些代码块，我们称之为“片段”。虽然片段能很好地推动你得生产力，但大多数的实现都有这样一个缺点：你必须先定义你得代码片段，并且不能再运行时进行拓展。 Emmet把片段这个概念提高到了一个新的层次：你可以设置CSS形式的能够动态被解析的表达式，然后根据你所输入的缩写来得到相应的内容。Emmet是很成熟的并且非常适用于编写HTML/XML 和 CSS 代码的前端开发人员，但也可以用于编程语言。 使用示例：在编辑器中输入缩写代码：ul&gt;li*5 ，然后按下拓展键（默认为tab），即可得到代码片段： 1234567&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 语法:后代：&gt;缩写：nav&gt;ul&gt;li 12345&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 兄弟：+缩写：div+p+bq 123&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;/blockquote&gt; 上级：^缩写：div+div&gt;p&gt;span+em^bq 12345&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt;&lt;/div&gt; 缩写：div+div&gt;p&gt;span+em^^bq 12345&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;/blockquote&gt; 分组：()缩写：div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p 1234567891011&lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 缩写：(div&gt;dl&gt;(dt+dd)*3)+footer&gt;p 12345678910111213&lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;footer&gt; &lt;p&gt;&lt;/p&gt;&lt;/footer&gt; 乘法：*缩写：ul&gt;li*5 1234567&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 自增符号：$缩写：ul&gt;li.item$*5 1234567&lt;ul&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 缩写：h$[title=item$]{Header $}*3 123&lt;h1 title=&quot;item1&quot;&gt;Header 1&lt;/h1&gt;&lt;h2 title=&quot;item2&quot;&gt;Header 2&lt;/h2&gt;&lt;h3 title=&quot;item3&quot;&gt;Header 3&lt;/h3&gt; 缩写：ul&gt;li.item$$$*5 1234567&lt;ul&gt; &lt;li class=&quot;item001&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item002&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item003&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item004&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item005&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 缩写：ul&gt;li.item$@-*5 1234567&lt;ul&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 缩写：ul&gt;li.item$@3*5 1234567&lt;ul&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item6&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item7&quot;&gt;&lt;/li&gt;&lt;/ul&gt; ID和类属性缩写：#header 1&lt;div id=&quot;header&quot;&gt;&lt;/div&gt; 缩写：.title 1&lt;div class=&quot;title&quot;&gt;&lt;/div&gt; 缩写：form#search.wide 1&lt;form id=&quot;search&quot; class=&quot;wide&quot;&gt;&lt;/form&gt; 缩写：p.class1.class2.class3 1&lt;p class=&quot;class1 class2 class3&quot;&gt;&lt;/p&gt; 自定义属性缩写：p[title=”Hello world”] 1&lt;p title=&quot;Hello world&quot;&gt;&lt;/p&gt; 缩写：td[rowspan=2 colspan=3 title] 1&lt;td rowspan=&quot;2&quot; colspan=&quot;3&quot; title=&quot;&quot;&gt;&lt;/td&gt; 缩写：[a=’value1’ b=”value2”] 1&lt;div a=&quot;value1&quot; b=&quot;value2&quot;&gt;&lt;/div&gt; 文本：{}缩写：a{Click me} 1&lt;a href=&quot;&quot;&gt;Click me&lt;/a&gt; 缩写：p&gt;{Click }+a{here}+{ to continue} 1&lt;p&gt;Click &lt;a href=&quot;&quot;&gt;here&lt;/a&gt; to continue&lt;/p&gt; 隐式标签缩写：.class 1&lt;div class=&quot;class&quot;&gt;&lt;/div&gt; 缩写：em&gt;.class 1&lt;em&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/em&gt; 缩写：ul&gt;.class 123&lt;ul&gt; &lt;li class=&quot;class&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 缩写：table&gt;.row&gt;.col 12345&lt;table&gt; &lt;tr class=&quot;row&quot;&gt; &lt;td class=&quot;col&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; HTML所有未知的缩写都会转换成标签，例如，foo →&lt; foo&gt; 缩写：! 12345678910&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 缩写：a 1&lt;a href=&quot;&quot;&gt;&lt;/a&gt; 缩写：a:link 1&lt;a href=&quot;http://&quot;&gt;&lt;/a&gt; 缩写：a:mail 1&lt;a href=&quot;mailto:&quot;&gt;&lt;/a&gt; 缩写：abbr 1&lt;abbr title=&quot;&quot;&gt;&lt;/abbr&gt; 缩写：acronym 1&lt;acronym title=&quot;&quot;&gt;&lt;/acronym&gt; 缩写：base 1&lt;base href=&quot;&quot; /&gt; 缩写：basefont 1&lt;basefont /&gt; 缩写：br 1&lt;br /&gt; 缩写：frame 1&lt;frame /&gt; 缩写：hr 1&lt;hr /&gt; 缩写：bdo 1&lt;bdo dir=&quot;&quot;&gt;&lt;/bdo&gt; 缩写：bdo:r 1&lt;bdo dir=&quot;rtl&quot;&gt;&lt;/bdo&gt; 缩写：bdo:l 1&lt;bdo dir=&quot;ltr&quot;&gt;&lt;/bdo&gt; 缩写：col 1&lt;col /&gt; 缩写：link 1&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; /&gt; 缩写：link:css 1&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; 缩写：link:print 1&lt;link rel=&quot;stylesheet&quot; href=&quot;print.css&quot; media=&quot;print&quot; /&gt; 缩写：link:favicon 1&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot; /&gt; 缩写：link:touch 1&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;favicon.png&quot; /&gt; 缩写：link:rss 1&lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;rss.xml&quot; /&gt; 缩写：link:atom 1&lt;link rel=&quot;alternate&quot; type=&quot;application/atom+xml&quot; title=&quot;Atom&quot; href=&quot;atom.xml&quot; /&gt; 缩写：meta 1&lt;meta /&gt; 缩写：meta:utf 1&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; 缩写：meta:win 1&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=windows-1251&quot; /&gt; 缩写：meta:vp 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot; /&gt; 缩写：meta:compat 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot; /&gt; 缩写：style 1&lt;style&gt;&lt;/style&gt; 缩写：script 1&lt;script&gt;&lt;/script&gt; 缩写：script:src 1&lt;script src=&quot;&quot;&gt;&lt;/script&gt; 缩写：img 1&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; 缩写：iframe 1&lt;iframe src=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; 缩写：embed 1&lt;embed src=&quot;&quot; type=&quot;&quot; /&gt; 缩写：object 1&lt;object data=&quot;&quot; type=&quot;&quot;&gt;&lt;/object&gt; 缩写：param 1&lt;param name=&quot;&quot; value=&quot;&quot; /&gt; 缩写：map 1&lt;map name=&quot;&quot;&gt;&lt;/map&gt; 缩写：area 1&lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot; /&gt; 缩写：area:d 1&lt;area shape=&quot;default&quot; href=&quot;&quot; alt=&quot;&quot; /&gt; 缩写：area:c 1&lt;area shape=&quot;circle&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot; /&gt; 缩写：area:r 1&lt;area shape=&quot;rect&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot; /&gt; 缩写：area:p 1&lt;area shape=&quot;poly&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot; /&gt; 缩写：form 1&lt;form action=&quot;&quot;&gt;&lt;/form&gt; 缩写：form:get 1&lt;form action=&quot;&quot; method=&quot;get&quot;&gt;&lt;/form&gt; 缩写：form:post 1&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;/form&gt; 缩写：label 1&lt;label for=&quot;&quot;&gt;&lt;/label&gt; 缩写：input 1&lt;input type=&quot;text&quot; /&gt; 缩写：inp 1&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:hidden 别名：input[type=hidden name] 1&lt;input type=&quot;hidden&quot; name=&quot;&quot; /&gt; 缩写：input:h 别名：input:hidden 1&lt;input type=&quot;hidden&quot; name=&quot;&quot; /&gt; 缩写：input:text, input:t 别名：inp 1&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:search 别名：inp[type=search] 1&lt;input type=&quot;search&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:email 别名：inp[type=email] 1&lt;input type=&quot;email&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:url 别名：inp[type=url] 1&lt;input type=&quot;url&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:password 别名：inp[type=password] 1&lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:p 别名：input:password 1&lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:datetime 别名：inp[type=datetime] 1&lt;input type=&quot;datetime&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:date 别名：inp[type=date] 1&lt;input type=&quot;date&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:datetime-local 别名：inp[type=datetime-local] 1&lt;input type=&quot;datetime-local&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:month 别名：inp[type=month] 1&lt;input type=&quot;month&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:week 别名：inp[type=week] 1&lt;input type=&quot;week&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:time 别名：inp[type=time] 1&lt;input type=&quot;time&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:number 别名：inp[type=number] 1&lt;input type=&quot;number&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:color 别名：inp[type=color] 1&lt;input type=&quot;color&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:checkbox 别名：inp[type=checkbox] 1&lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:c 别名：input:checkbox 1&lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:radio 别名：inp[type=radio] 1&lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:r 别名：input:radio 1&lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:range 别名：inp[type=range] 1&lt;input type=&quot;range&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:file 别名：inp[type=file] 1&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:f 别名：input:file 1&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:submit 1&lt;input type=&quot;submit&quot; value=&quot;&quot; /&gt; 缩写：input:s 别名：input:submit 1&lt;input type=&quot;submit&quot; value=&quot;&quot; /&gt; 缩写：input:image 1&lt;input type=&quot;image&quot; src=&quot;&quot; alt=&quot;&quot; /&gt; 缩写：input:i 别名：input:image 1&lt;input type=&quot;image&quot; src=&quot;&quot; alt=&quot;&quot; /&gt; 缩写：input:button 1&lt;input type=&quot;button&quot; value=&quot;&quot; /&gt; 缩写：input:b 别名：input:button 1&lt;input type=&quot;button&quot; value=&quot;&quot; /&gt; 缩写：isindex 1&lt;isindex /&gt; 缩写：input:reset 别名：input:button[type=reset] 1&lt;input type=&quot;reset&quot; value=&quot;&quot; /&gt; 缩写：select 1&lt;select name=&quot;&quot; id=&quot;&quot;&gt;&lt;/select&gt; 缩写：option 1&lt;option value=&quot;&quot;&gt;&lt;/option&gt; 缩写：textarea 1&lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; 缩写：menu:context 别名：menu[type=context]&gt; 1&lt;menu type=&quot;context&quot;&gt;&lt;/menu&gt; 缩写：menu:c 别名：menu:context 1&lt;menu type=&quot;context&quot;&gt;&lt;/menu&gt; 缩写：menu:toolbar 别名：menu[type=toolbar]&gt; 1&lt;menu type=&quot;toolbar&quot;&gt;&lt;/menu&gt; 缩写：menu:t 别名：menu:toolbar 1&lt;menu type=&quot;toolbar&quot;&gt;&lt;/menu&gt; 缩写：video 1&lt;video src=&quot;&quot;&gt;&lt;/video&gt; 缩写：audio 1&lt;audio src=&quot;&quot;&gt;&lt;/audio&gt; 缩写：html:xml 1&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;/html&gt; 缩写：keygen 1&lt;keygen /&gt; 缩写：command 1&lt;command /&gt; 缩写：bq 别名：blockquote 1&lt;blockquote&gt;&lt;/blockquote&gt; 缩写：acr 别名：acronym 1&lt;acronym title=&quot;&quot;&gt;&lt;/acronym&gt; 缩写：fig 别名：figure 1&lt;figure&gt;&lt;/figure&gt; 缩写：figc 别名：figcaption 1&lt;figcaption&gt;&lt;/figcaption&gt; 缩写：ifr 别名：iframe 1&lt;iframe src=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; 缩写：emb 别名：embed 1&lt;embed src=&quot;&quot; type=&quot;&quot; /&gt; 缩写：obj 别名：object 1&lt;object data=&quot;&quot; type=&quot;&quot;&gt;&lt;/object&gt; 缩写：src 别名：source 1&lt;source&gt;&lt;/source&gt; 缩写：cap 别名：caption 1&lt;caption&gt;&lt;/caption&gt; 缩写：colg 别名：colgroup 1&lt;colgroup&gt;&lt;/colgroup&gt; 缩写：fst, fset 别名：fieldset 1&lt;fieldset&gt;&lt;/fieldset&gt; 缩写：btn 别名：button 1&lt;button&gt;&lt;/button&gt; 缩写：btn:b 别名：button[type=button] 1&lt;button type=&quot;button&quot;&gt;&lt;/button&gt; 缩写：btn:r 别名：button[type=reset] 1&lt;button type=&quot;reset&quot;&gt;&lt;/button&gt; 缩写：btn:s 别名：button[type=submit] 1&lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;","tags":[{"name":"Emmet","slug":"Emmet","permalink":"http://yoursite.com/tags/Emmet/"},{"name":"工具篇","slug":"工具篇","permalink":"http://yoursite.com/tags/工具篇/"}]},{"title":"CSS3动画","date":"2015-05-29T04:25:21.000Z","path":"2015/05/29/CSS3动画/","text":"CSS3动画通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。 1、转换 transform实现对元素的移动、缩放、转动、倾斜。转换是使元素改变形状、尺寸和位置的一种效果。 可以使用 2D 或 3D 转换来转换您的元素。 浏览器支持Internet Explorer 10、Firefox、Opera 支持 transform 属性。 Internet Explorer 9 支持替代的 -ms-transform 属性（仅适用于 2D 转换）。 Safari 和 Chrome 支持替代的 -webkit-transform 属性（3D 和 2D 转换）。 Opera 只支持 2D 转换。 语法1transform: none|transform-functions; 值 描述 none 定义不进行转换。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate(x,y) 定义 2D 转换。 translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。 translateY(y) 定义转换，只是用 Y 轴的值。 translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿着 X 轴的 3D 旋转。 rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n) 为 3D 转换元素定义透视视图。 2Dtransform-styletransform-style: flat; 默认值，表示所有子元素在2D平面呈现（设置在父元素中） transform-origin指定元素的原点transform-orign :center（默认，中心点）transform-orign: left centertransform-orign: 40% 50%transform-orign: 20px 30px translate 平移translate(x, y)​ 沿着X和Y轴移动元素，参数为像素值translateX(n)​ 沿着X轴移动translateY(n)​ 沿着Y轴移动 scale 缩放scale(x, y)​ 改变元素的宽度和高度，参数为缩放倍数scaleX(n)​ 改变元素的宽度scaleY(n)​ 改变元素的高度 rotate 旋转rotate(angle)​ 参数为旋转角度，单位deg skew 倾斜/斜切skew(x-angle, y-angle)​ 参数为倾斜角度，单位degskewX(angle)skewY(angle) 3Dtransform-styletransform-style: preserve-3d 表示所有子元素在3D空间中呈现（设置在父元素-也就是舞台元素中） perspectiveperspective: 20000px;​ 设置镜头距离 或者叫 透视距离 子元素会起作用(用在舞台元素上)transform: perspective(20000px);​ 用在当前变形元素上，效果同上 perspective-origin用来决定perspective属性的源点角度，实际设置了x轴和y轴的位置属性值是像素值或者百分比，或者（left/center/right，top/center/bottom） 默认为（50%，50%） backface-visibility决定元素旋转背面是否可见属性值为visible(默认值，反面可见)/hidden(反面不可见) translate 平移translate3d(x, y, z)translateZ(n) scale 缩放scale3d(x, y, z)scaleZ(n) rotate 旋转rotate3d(1,1,1,45deg)前三个 参数中最大的值 代表把后面的角度分为多少份 然后三个值分别占几分 最后一个参数为角度rotateX(n)rotateY(n)rotateZ(n) 2、过渡 transition通过transition，我们可以在不使用Flash动画或JS的情况下， 当元素从一种样式变换为另一种样式时为元素添加效果。IE9及之前版本不支持 transition-property规定应用过渡的CSS属性的名称 transition-duration定义过渡效果花费的时间。默认是0 transition-timing-function规定过渡效果的时间曲线。默认ease 语法12transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n); 值​ linear 匀速运动​ ease 慢，快，慢​ ease-in 慢，快​ ease-out 快，慢​ ease-in-out 慢，快，慢 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 transition-delay规定过渡效果延迟时间。默认0 transition复合属性，用于在一个属性中设置四个过渡属性（至少设置两个属性值：样式名称 过渡时间）可以同时改变多个属性的过渡 以”,” 进行分隔, 如 transition: width 3s,height 3s,margin-left 3s,margin-top 3s 触发过渡伪元素触发 如 ：hover媒体查询触发js事件触发 3、动画 animation关键帧 @keyframes@keyframes 动画名 {​ from {​ }​ to {​ } } @keyframe 动画名 {​ 0% {​ }​ 50% {​ }​ 100% {​ } } 定义和用法通过 @keyframes 规则，您能够创建动画。 创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。 在动画过程中，您能够多次改变这套 CSS 样式。 以百分比来规定改变发生的时间，或者通过关键词 “from” 和 “to”，等价于 0% 和 100%。 0% 是动画的开始时间，100% 动画的结束时间。 为了获得最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 注释：请使用动画属性来控制动画的外观，同时将动画与选择器绑定。 语法1@keyframes animationname &#123;keyframes-selector &#123;css-styles;&#125;&#125; 值 描述 animationname 必需。定义动画的名称。 keyframes-selector 必需。动画时长的百分比。 合法的值： 0-100% from（与 0% 相同） to（与 100% 相同） css-styles 必需。一个或多个合法的 CSS 样式属性。 实例1、在一个动画中添加多个 keyframe 选择器： 1234567891011121314151617181920212223242526@keyframes mymove&#123; 0% &#123;top:0px;&#125; 25% &#123;top:200px;&#125; 50% &#123;top:100px;&#125; 75% &#123;top:200px;&#125; 100% &#123;top:0px;&#125;&#125;@-moz-keyframes mymove /* Firefox */&#123; 0% &#123;top:0px;&#125; 25% &#123;top:200px;&#125; 50% &#123;top:100px;&#125; 75% &#123;top:200px;&#125; 100% &#123;top:0px;&#125;&#125;@-webkit-keyframes mymove /* Safari 和 Chrome */&#123; 0% &#123;top:0px;&#125; 25% &#123;top:200px;&#125; 50% &#123;top:100px;&#125; 75% &#123;top:200px;&#125; 100% &#123;top:0px;&#125;&#125; 2、在一个动画中改变多个 CSS 样式： 1234567891011121314151617181920212223@keyframes mymove&#123; 0% &#123;top:0px; background:red; width:100px;&#125; 100% &#123;top:200px; background:yellow; width:300px;&#125;&#125;@-moz-keyframes mymove /* Firefox */&#123; 0% &#123;top:0px; background:red; width:100px;&#125; 100% &#123;top:200px; background:yellow; width:300px;&#125;&#125;@-webkit-keyframes mymove /* Safari 和 Chrome */&#123; 0% &#123;top:0px; background:red; width:100px;&#125; 100% &#123;top:200px; background:yellow; width:300px;&#125;&#125;@-o-keyframes mymove /* Opera */&#123; 0% &#123;top:0px; background:red; width:100px;&#125; 100% &#123;top:200px; background:yellow; width:300px;&#125;&#125; 3、带有多个 CSS 样式的多个 keyframe 选择器： 1234567891011121314151617181920212223242526272829303132333435@keyframes mymove&#123; 0% &#123;top:0px; left:0px; background:red;&#125; 25% &#123;top:0px; left:100px; background:blue;&#125; 50% &#123;top:100px; left:100px; background:yellow;&#125; 75% &#123;top:100px; left:0px; background:green;&#125; 100% &#123;top:0px; left:0px; background:red;&#125;&#125;@-moz-keyframes mymove /* Firefox */&#123; 0% &#123;top:0px; left:0px; background:red;&#125; 25% &#123;top:0px; left:100px; background:blue;&#125; 50% &#123;top:100px; left:100px; background:yellow;&#125; 75% &#123;top:100px; left:0px; background:green;&#125; 100% &#123;top:0px; left:0px; background:red;&#125;&#125;@-webkit-keyframes mymove /* Safari and Chrome */&#123; 0% &#123;top:0px; left:0px; background:red;&#125; 25% &#123;top:0px; left:100px; background:blue;&#125; 50% &#123;top:100px; left:100px; background:yellow;&#125; 75% &#123;top:100px; left:0px; background:green;&#125; 100% &#123;top:0px; left:0px; background:red;&#125;&#125;@-o-keyframes mymove /* Opera */&#123; 0% &#123;top:0px; left:0px; background:red;&#125; 25% &#123;top:0px; left:100px; background:blue;&#125; 50% &#123;top:100px; left:100px; background:yellow;&#125; 75% &#123;top:100px; left:0px; background:green;&#125; 100% &#123;top:0px; left:0px; background:red;&#125;&#125; animation-name指定关键帧动画的名字，这个动画名必须对应一个@keyframes规则 请始终规定 animation-duration 属性，否则时长为 0，就不会播放动画了。 浏览器支持Internet Explorer 10、Firefox 以及 Opera 支持 animation-name 属性。 Safari 和 Chrome 支持替代的 -webkit-animation-name 属性。 Internet Explorer 9 以及更早的版本不支持 animation-name 属性。 注意: 下面的其他动画的属性浏览器支持情况同animation-name 语法1animation-name: keyframename|none; 值 描述 keyframename 规定需要绑定到选择器的 keyframe 的名称。 none 规定无动画效果（可用于覆盖来自级联的动画）。 实例为 @keyframes 动画规定一个名称： 12345div&#123; animation-name:mymove; -webkit-animation-name:mymove; /* Safari 和 Chrome */&#125; animate-duration:设置动画持续时间 语法1animation-duration: time; 值 描述 time 规定完成动画所花费的时间。默认值是 0，意味着没有动画效果。 实例：动画执行时间为2秒 12345div&#123; animation-duration:2s; -webkit-animation-duration:2s; /* Safari 和 Chrome */&#125; animation-timing-function:animation-timing-function: ease-in-out; 规定动画的速度曲线。速度曲线定义动画从一套 CSS 样式变为另一套所用的时间。 速度曲线用于使变化更为平滑。 动画播放效果，与transition-timing-function类似 语法1animation-timing-function: value; animation-timing-function 使用名为三次贝塞尔（Cubic Bezier）函数的数学函数，来生成速度曲线。您能够在该函数中使用自己的值，也可以预定义的值： 值 描述 linear 动画从头到尾的速度是相同的。 ease 默认。动画以低速开始，然后加快，在结束前变慢。 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 实例从开头到结尾以相同的速度来播放动画： 12345div&#123; animation-timing-function:2s; -webkit-animation-timing-function:2s; /* Safari 和 Chrome */&#125; animation-delay:定义动画动画延迟时间，animation-delay 值以秒或毫秒计。 提示：允许负值，-2s 使动画马上开始，但跳过 2 秒进入动画。 语法1animation-delay: time; 值 描述 time 可选。定义动画开始前等待的时间，以秒或毫秒计。默认值是 0。 实例等待两秒，然后开始动画： 12345div&#123; animation-delay:2s; -webkit-animation-delay:2s; /* Safari 和 Chrome */&#125; animation-iteration-count定义动画的播放次数，infinite为无限次 animation-iteration-count: 10; 定义循环次数, infinite为无限次 语法1animation-iteration-count: n|infinite; 值 描述 n 定义动画播放次数的数值。 infinite 规定动画应该无限次播放。 实例播放动画三次： 12345div&#123; animation-iteration-count:3; -webkit-animation-iteration-count:3; /* Safari 和 Chrome */&#125; animation-direction指定动画的播放方向，如果 animation-direction 值是 “alternate”，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等）向后播放。 注释：如果把动画设置为只播放一次，则该属性没有效果。 语法1animation-direction: normal|alternate; 值 描述 normal 默认值。动画应该正常播放。 alternate 交替轮流，动画应该轮流向前/反向播放 实例暂停动画： 12345div&#123; animation-direction: alternate; -webkit-animation-direction: alternate; /* Safari 和 Chrome */&#125; animation-play-state设置动画的播放状态，运行还是暂停 语法1animation-play-state: paused|running; 值 描述 paused 规定动画已暂停。 running 规定动画正在播放。默认）从开始或者暂停的位置重新播放 animation-fill-mode属性规定动画在播放之前或之后，其动画效果是否可见。 其属性值是由逗号分隔的一个或多个填充模式关键词。 语法1animation-fill-mode : none | forwards | backwards | both; 值 描述 none 不改变默认行为。动画结束后返回初始帧处 forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。动画结束后继续应用最后帧的位置 backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 both 向前和向后填充模式都被应用。动画同时具有forwards和backwards的效果 实例为 h1 元素规定填充模式： 1234h1&#123; animation-fill-mode: forwards;&#125; animation复合属性animation 属性是一个简写属性，复合属性，用于设置六个动画属性： animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction 注释：请始终规定 animation-duration 属性，否则时长为 0，就不会播放动画了。 语法1animation: name duration timing-function delay iteration-count direction; 值 描述 animation-name 规定需要绑定到选择器的 keyframe 名称。 animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。 animation-direction 规定是否应该轮流反向播放动画。 实例12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt; &lt;style&gt; div &#123; width:100px; height:100px; background:red; position:relative; animation:mymove 5s infinite; -webkit-animation:mymove 5s infinite; /*Safari and Chrome*/ &#125; @keyframes mymove &#123; from &#123;left:0px;&#125; to &#123;left:200px;&#125; &#125; @-webkit-keyframes mymove /*Safari and Chrome*/ &#123; from &#123;left:0px;&#125; to &#123;left:200px;&#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}]},{"title":"CSS3简介","date":"2015-05-20T06:03:21.000Z","path":"2015/05/20/CSS3简介/","text":"CSS3介绍CSS版本 CSS1: 定义了网页的基本属性：字体，颜色，补白，基本选择器等等。CSS2：添加了高级功能：浮动，定位，高级选择器（子选择器，相邻选择器，通用选择器）CSS3：遵循模块化开发。发布时间并不是一个时间点，而是时间段。（2002-至今） CSS3选择器css3开始新增新特性（1）CSS选择器 ​ http://www.w3school.com.cn/cssref/css_selectors.asp ​ http://www.cnblogs.com/libingql/p/4375354.html（2）新的颜色制式和透明设定 ​ http://blog.csdn.net/u012612399/article/details/50205485（3）多栏布局的实现 ​ http://blog.csdn.net/cinderella_hou/article/details/52155185 ​ http://www.diannao.wang/css/2015/48-14305.html（4）多背景图效果 ​ http://caibaojian.com/css3-multiple-background.html（5）文字阴影效果（6）开放的网络字体类型 ​ http://blog.csdn.net/u014328357/article/details/52859321（7）圆角（8）边框背景图片（9）盒子阴影（10）媒体查询 1、伪元素选择器:first-line匹配内容的第一行 :first-letter匹配内容的第一个字符 :before在元素内容之前插入一些内容，需要配合content属性 :after在元素之后插入一些内容，需要配合content属性 常用于清除浮动 #ff:after { content: ‘’; clear: both; display: block; *zoom: 1;} ::selection选中的时候文字的样式 IE9支持，火狐得加-moz- 谷歌支持 只接受两个属性 background, color 2、目标伪类选择器:target使用target选择器对页面中的某个target元素(锚点)指定样式 该样式只在用户点击了页面中的超链接,并且跳转到target元素后起作用 可用于实现tab切换 3、状态伪类选择器:focus获取焦点的时候触发 :disabled设置禁用状态下的样式 :enabled设置没有被禁用状态下的样式 :read-only只读 :read-write可读可写 :checked给单选、多选设置选中的样式 4、结构伪类选择器:root匹配页面的根元素 :empty内容为空的元素 :first-child在父元素下找第一个子元素 :last-child在父元素下找最后一个子元素 :nth-child(n)在父元素下找第n个子元素（ n是从1开始的整数） :nth-last-child(n)在父元素下找倒数第n个子元素 :only-child父元素下只有唯一 一个元素则生效 :nth-child(odd)父元素下序号为奇数的子元素，也可以写成:nth-child(2n-1) :nth-child(even)父元素下序号为偶数的子元素，也可以写成:nth-child(2n) :first-of-type在父元素下找第一个指定元素（不计算其余类型的元素） :last-of-type在父元素下找最后一个指定元素 :nth-of-type(n)在父元素下找指定元素 第n个（ n是从1开始的整数） :nth-last-of-type(n)在父元素下找指定元素 倒数第n个 :only-of-type父元素只包含一个同类型的子元素时生效（可以有多个其余类型的子元素） 5、否定伪类选择器:not( )除了括号内的元素 6、层次选择器E+F相邻(后一个)兄弟选择器 E~F通用(后面所有)兄弟选择器 7、属性选择器E[attr]选择带有attr属性的所有E元素，支持E[attr1] [attr2]多属性选择器 E[attr = val]选择带有attr属性且属性值为val的所有E元素 E[attr |= val]选择带有attr属性且属性值为val或者以var-开头的所有E元素 E[attr ~= val]选择attr属性包含一个或多个属性值（用空格隔开），其中一个值为val 的所有E元素 E[attr *= val]选择带有attr属性且属性值包含字符串‘val’（如vals，value等） 的所有E元素 E[attr ^= val]选择带有attr属性且属性值为以var开头的所有E元素（与E[attr |= val]的区别是不需要-） E[attr $= val]选择带有attr属性且属性值为以var结尾的所有E元素。运用在一些特殊的链接加背景图很方便， 比如给PDF/PNG/DOC等不同文件加不同ICON图标，a[href $= png] CSS3其他1、文字阴影text-shadow：x轴偏移量 y轴偏移量 阴影模糊半径(可省略) 阴影颜色 2、单词换行word-break:break-all/break-word 3、盒子阴影box-shadow：x轴偏移量 y轴偏移量 阴影模糊半径(可省略) 阴影大小(可省略) 阴影颜色 4、圆角border-radius4个参数：左上 右上 右下 左下3个参数：左上 右上/左下 右下2个参数：左上/右下 右上/左下1个参数：所有角 参数可以是像素值或百分比(相对自身宽高) 5、图片边框border-imagesource图片路径 slice图片边框向内偏移,用来分解引入的图片,拆分成九宫格例如:border-image-slice:10 10 10 10 width图片边框宽度 outset边框图像区域超出边框的量 repeat边框是否应平铺(repeated),铺满(round),拉伸(stretch) 6、背景图片大小background-size像素值/百分比如果只写一个,第二个默认auto cover等比例缩放到完全覆盖容器，背景图像有可能超出容器 contain完全包含图片，一端完全撑开，另一端等比例缩放 auto真实大小 background-positioncenter center 保证图片拉伸后，视觉中心在最中间 7、渐变线性渐变​ background: linear-gradient(0deg,red,yellow,green)​ 第一个参数多种写法​ to left bottom​ to bottom​ 10deg 弧形渐变​ background: radial-gradient(at left top,red,yellow)​ 第一个参数不写默认在中间 CSS性能优化http://www.jianshu.com/p/268c7f3dd7a6 http://blog.jobbole.com/35339/","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Web安全指南","date":"2015-04-20T04:01:40.000Z","path":"2015/04/20/Chrome console使用指南 - 副本/","text":"","tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"}]}]