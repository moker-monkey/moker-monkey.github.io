[{"title":"学习《精通Javascript》笔记之面向对象的特性","date":"2016-07-22T07:08:32.000Z","path":"2016/07/22/《精通Javascript》学习笔记/","text":"学习《精通Javascript》笔记 《精通 Javascript 》作者是：【美国】 John Resig ,他是著名框架jQuery的作者,因此选择该作者的著作来拜读,可以对jQuery框架有更深刻的认识,也对JavaScript 会有更深刻的认识,这就是选择这本书的原因,我已经迫不及待了,让我们开始吧! 第一部分:面向对象的 JavaScript ​ 第一章,对 JavaScript 中较为经典的部分做了简单点评,该书的主要知识点将围绕以下5点进行展开: 面向对象的特性; 操作DOM; 注册事件(event) Javascript 与 CSS 的交互 Ajax的实现原理 第二部分:专业的 Javascript 开发 ​ 第二章,面向对象的 JavaScript 围绕面向对象的特性和细节进行了经典的描述和解释. 主要围绕着以下问题: ​ 1.引用(reference) ​ 2.作用域(scope) ​ 3.闭包(closure) ​ 4.上下文(context) 进行了详细的描述,这里,我就带着疑问和实践,一同和大家进行详细分析! 一,引用:&gt;概念:引用是面向对象实现的基础,而非一般的赋值的浅拷贝,你拿到的不是副本! 例如: 123456var obj = new Object() //实例化一个对象obj.name = &quot;小铭&quot;; //实例化一个对象var objRef = obj; //创建一个引用console.log(objRef.name) //结果是小铭objRef.name = &quot;大铭&quot;;console.log(obj.name) //结果是大铭 那么既然地址是相同的,如果我更改obj的地址指向时,objRef也应该修改才对(接着上一个代码) 123obj = new object(); //将obj从新赋一个新对象console.log(objRef.name) // 大铭console.log(obj.name) // undefined 然而实际情况却是objRef依然指向的是旧的对象 这就意味着,在 Javascript 中的 new 操作,实际上是创建了一个新的对象 ,而非改变原有地址,而原地址由于有引用,也没有被垃圾回收机制回收; 而不是浅拷贝 在 Javascript 中的=号都是”引用”符号而非 赋值! 所以你常见的:字符串,数字,数组,布尔值,function,对象的=号其实都是引用 ; 1234var str = &quot;hellow world&quot;;var strRef = str; //这是引用var num = 100 ;var numRef = num; //这是引用 当你看到这里,你会疑惑,那为什么对象中的引用,在对象进行修改时引用中的值也会进行修改,而上面几行代码在改变 str 之后 strRef 并没有做出相应的改变啊?他们难道不是指向同一地址的吗? ​ 我们看原话: 引用( reference )的概念是 Javascript 的基础之一,”引用”是一个指向对象实际位置的指针,但是有一个前提:实际的对象肯定不是引用。字符串永远是字符串，数组永远是数组。不过多个变量却指向同一对象。JavaScript 基于的就是这样的引用系统。此外，对象可以包含一系列的属性（property），这些属性也都不过是其他对象的引用，一旦该对象的类型改变，则所有的引用也都会改变 123var str = &quot;hellow world&quot;; //创造一个实际赋值,在window上声明一个引用指向赋值的地址;var strRef = str; //这是引用str += &quot;new&quot;; 这段话的大意是说:上面的str 是 “hellow world”的引用,而 strRef 又是 str 的引用,当 str =”new” 时,实际上str 指向了创建的新的值,而 strRef 还是指向原来值的位置,因此strRef并没有随之而改变;在实际使用中将 strRef 看做str的副本拷贝表面上看也没有上面毛病,新手都是这样过来的,但稍微一思考,为什么strRef也可以调用到String的方法呢?侧面说明了strRef 事实上是个引用,想想在其他语言里面,如果只是拷贝的话,那么我们对strRef的操作就是调用其他对象的方法来进行加工而非调用方法,我们也可以通过这样的方法来验证; 12var str = new String(&quot;some&quot;);console.log(str); 你在打印的对象中会发现一个隐藏的属性[[PrimitiveValue]]; 而我们实际上需要的并不是一个对象,而是一个值,在函数中是这样写的 12var str = String(&quot;some&quot;);console.log(str); 在这里我们实际上就是调用了 String 的构造函数,该构造函数直接执行时 return 出了一个属性,但是由于[[PrimitiveValue]]属性被浏览器隐藏起来了([[]]代表浏览器中的隐藏属性),我也只能够猜测大概是这样的 1234function String(str)&#123; return this.PrimitiveValue = str;&#125;var str = String(&quot;some&quot;); 但是你又会疑惑,我们平时都是这样声明一个字符串的呀?怎么会调用到构造函数呢? 12var str = &quot;some&quot;;console.log(str.constructor == String); //true; 看完这句话,又会有新的疑惑,你确定 var 出来值是一个引用?而不是只有对象才有引用吗?请看原话第二段,对象可以包含一系列的属性,这些属性也都不过是其他对象的引用, 而 var 出来的变量实际上也是 window 对象的一个属性,使用引用的好处就在于,所有的引用都指向了原对象,那么也就可以直接调用原对象的方法,而不是使用元对象的方法进行加工.配合链式调用,可以减少变量的创建,进而减少内存的分配; 可以看下方拓展,这样就能够理解:所有=号实际上都是引用符号,而改变其中一个引用的指向,并不会影响另一个引用,非对象的引用每次赋值都是改变引用的指向 而由于原引用一直指向内存,因此原引用并不会被垃圾回收机制所回收:所以代码能够使用链式调用的地方就尽量不要创建新的引用; 拓展:如果说Javascript一切皆对象,那么Javascript都有哪些对象? EMCAJavascript 5.1中的对象本地对象(Native objects): ​ 本地对象有时被称为“全局对象”,”ES规范对象”，因为它们是JavaScript本来可以使用的对象。不要将术语全局对象(global)与作为作用域链的最高级别的“head”全局对象混淆，例如，所有Web浏览器中的“window”对象（head）; 下面列出了用JavaScript预先打包的9个本地对象构造函数：​ Number（）String（）Boolean（）Object（）Array () Function（）Date（）RegExp（）Error JavaScript主要是从这9个对象（以及字符串，数字和布尔值 - 原始值 - 它们的相等性基于值不是参考）构造的。 如果你直接调用构造函数（Number（），String（）和Boolean（）），就返回一个复杂的对象。如果你只是在代码中表示一个数字，字符串或布尔值（原始值，如5，“foo”和true），那么构造函数将返回一个原始值，而不是一个复杂的对象值。 “window”/head对象 而所有 var 声明出来的变量都是window的一个属性,我们可以这样论证 123456var a= 2;for(x in window)&#123; if(window[x] === a)&#123; console.log(x) //a &#125;&#125; 如果你想看的更详细也可以 1console.log(this); 你如果你眼力够好会很容易找到其中的Window中的a的; 如果你打开Window对象会发现一个首字母小写window的属性.而点击小window又会打开一个新的window,无穷尽; 网络上,一种模糊的说法是, Window 是主机对象和本地对象交互的地方,个人认为 Window 是存储变量的地方也是dom,事件等方法存储并供浏览器调用的地方; 主机对象(Host objects) ​ 运行JavaScript代码的主机环境（例如web浏览器）通常提供head/window对象（例如web浏览器中的窗口对象），其中语言的本地部分与主机对象（例如web浏览器中的window.location）和用户定义的对象（例如您的写代码在Web浏览器中运行的代码）,简单来说,可以操作浏览器的对象都是属于主机对象.而存在兼容性问题 的代码都是出于主机对象当中; 函数重载(overload)和类型检查​ Java中的函数重载一般是指在实例对象中不满意父级的方法而进行重写覆盖,而书中原文中的重载是通过判断传入参数数量的能力和判断传入参数类型,这一点也是jQuery如此传奇的所在之处,也被后来的Vue.js等框架所吸收利用. JavaScript 中函数重载的两个例子: 例子一: 123456789101112131415161718function sendMessage( msg , obj)&#123; if( arguments.length == 2)&#123; obj.handleMsg(msg); &#125;else&#123; alert( msg); &#125;&#125;//仅用一个参数调用这个函数 - 用 alert 来显示此消息sendMessage( &quot;Hello, World!&quot; ); // 弹出 Hello, World!//又或者我们可以传入一个对象sendMessage( &quot;How are you?&quot;,&#123; handleMag:function(msg)&#123; alert(&quot;This is a custom message:&quot;+mag); &#125;&#125;) //弹出This is a custom message:How are you?//这里扩展一下,你就可以发现Vue.js中的new vue(&#123;&#125;)的内部实现其实也类似于这样的,以及commonJs中的配置文件,或者配置Json文档,当做一个对象传入配置器; 例子二: 1234567891011121314// 一个接受任意数量参数并将其转换为数组的函数function makeArray()&#123;//临时使用的数组var arr = [];//遍历传入的每个参数for(var i= 0;i&lt;arguments.length;i++)&#123;arr.push( arguments[i]);&#125;//结果返回数组return arr&#125;//这个再扩展一下,可以对比ES6中的promise或者angular中的$q,和监听者模式; 既然要使用函数重载,那么就需要判断参数传入的类型 判断类型的两种方法:typeof / .constructor, typeof 可以检测非对象类的参数 .constructor可以返回其构造器,是每一个对象都包含的属性 第一种大家已经用的很多了,那么我就只说一下第二种 例子: 123&#123;&#125;.constructor == Object; //true&quot;str&quot;.constructor == String //turefunction foo()&#123;&#125;;foo.construcot == Function //ture 作用域( scope ):ECMA Javascript 5.1中规定,只有函数级作用域和全局作用域,在浏览器加载脚本时,会将“声明”进行提升,也就是说在其它语言中可能报错的情况下,Js可能只会输出 undefined ; 例如: 12console.log(go);var go = 2; 实际上由于”声明提升”,浏览器将该变量变为了 123var go;console.log(go)go = 2; 对于声明的函数,也有”声明提升” 例如: 1234go();function go()&#123; console.log(&quot;hellow world!&quot;)&#125; 实际上由于”声明提升”,浏览器将声明的变量写为: 12function go()&#123;console.log(&quot;hellow world!&quot;)&#125;go(); 需要注意的是: 123456foo();var foo = function()&#123;&#125;;-----------提升------------var foo;foo();foo = function()&#123;&#125;; 该表达式说明了,”声明提升”只会提升等式左边的声明;而右边绝不可能有声明 而函数作用域内的声明也会被提前: 例如: 1234function go()&#123;console.log(a); //undefinedvar a = 2;&#125; 而对于函数作用域内声明过的变量被”声明提升”为: 12345function go()&#123;var a;console.log(a);a = 2;&#125; 对变量的查询方式 : ​ 会先在当前作用域中先进行查看,如果有则使用当前作用域内声明的变量,如果没有则向上一个作用域中去查找,因此一定要注意书写规范,凡是声明变量时在该变量出现在 “=” 左边之前就应该将值初始化 ; 综上几点结论就是:声明提前是浏览器编译Js代码时进行的隐式工作,必须要谨慎对待,凡是声明时便对其赋值 ,可以有效的避免该错误; 拓展:ES6中的作用域规范​ ES6中新增了块级(block)作用域,更符合后端人员的口味,也使得Js代码更规范和健壮,为此新增了let 和 const 来进行块级作用域的声明,例如那个闭包经典问题,在for循环中引用的外全局变量不再是计算过的值,而是被定义时的值,而非执行时的值! ​ 1.let 命令:使用let进行声明的变量将不会提前,无论他在哪里(函数内,全局,块),但是在函数作用域内,虽然不会提升,但是会造成一个“暂时性死区”（temporal dead zone，简称 TDZ）,也就是在(块,函数内)如果有和上一作用域的声明冲突,那么在let声明之前都无法读取到该声明; 也就是说 12345678910111213if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125;//解决的方法就是,如果需要获取到作用域外的某变量时,作用域内不要有重复声明!!//如果有,尽量保持声明写在区域作用域的顶部 ES6规定了块级作用域内也能够声明函数,但该函数无法在块级作用域外使用 由于变量无需提升,那么let将会逐行解析 闭包(closure) 闭包( closure )意味着内层的函数可以引用存在包围它的函数内的变量, 即使外层函数的执行已终止. 闭包,的常用方式, 一、用来封装一些函数，可以减少引用的存在，例如： 12345function gitTime(msg, time)&#123; setTimeout(function()&#123; alert(msg) &#125;,time);&#125; 二、使用闭包来隐藏全局作用域变量 (当然在ES6中解决了这个问题) 123456(function()&#123;var msg = &quot;Thanks for visiting&quot;; window.onunload = function()&#123; alert(msg) &#125;&#125;)(); 闭包的经典问题: 假设有10个div. 1234567var div = document.querySelectorAll(&quot;div&quot;);for(var i = 0;i &lt; 10;i++)&#123; div[i].onclick = function()&#123; console.log(i); &#125;&#125;//答案大家都知道,无论你点哪一个div都会打印10; 书中说函数内拿到的是最终值,但并没有说明原因:我认为这是因为当执行该函数时,执行的位置已经在循环执行完之后,因此如果将函数的调用放在当前即可解决该问题,这也使用了闭包的作用,引用了外层函数的值,当外层函数销毁,内层函数的值不会被销毁因此虽然函数执行完毕,但是i由于有了内部的引用并不会被销毁,当外层函数执行完毕之后,由于i的值被赋予内部进行引用,因此并没有销毁; 123456789var div = document.getElementsByTagName(&quot;div&quot;);for(var i = 0;i &lt; div.length;i++)&#123;function foo(i)&#123; div[i].onclick = function()&#123; console.log(i); &#125;&#125;foo(i);&#125; 当然,为了节省引用 可以使用匿名函数来进行包装 12345678var div = document.getElementsByTagName(&quot;div&quot;);for(var i = 0;i &lt; div.length;i++)&#123;(function (i)&#123; div[i].onclick = function()&#123; console.log(i); &#125;&#125;)(i);&#125; 如果觉得晦涩难懂也可以写成这个样子 123456789var div = document.getElementsByTagName(&quot;div&quot;);for(var i = 0;i &lt; div.length;i++)&#123; div[i].onclick = wrap(i); function wrap(i)&#123; return function ()&#123; console.log(i); &#125; &#125;&#125; 这就是外层函数虽然销毁,但是内层函数对外层函数的引用依然存在 这就是闭包应用的场景,当我们需要延迟执行某一个函数时,而该函数需要引用外部的值,但是该值的计算又提前于函数执行之后,那么就可以使用闭包来解决该问题 上下文 在 JavaScript 中,代码总是有一个上下文对象(代码处在该对象内)。上下问对象是通过 this 变量体现的,这个变量永远指向当前代码所处的对象中。即使是在全局变量中 this 也是指向 widow 对象的。 1.在上下问对象内使用函数并将其上下文对象切换为另一个变量； 123456789var obj = &#123; yes:function()&#123; 此时的this指向的是obj this.var = true; &#125;, no: function()&#123; this.val = false; &#125; &#125; 讲到这,绝大多数新手都会范一个错误; 1234var obj=&#123; this.val = 10, this.name = &quot;xiaoming&quot;&#125; 这里注意 var出来的对象,最终调用者其实是window,不要忘记上面有关引用的拓展知识; 因此需要使用函数来切换 this 的指向,至于为什么要这样,我只能说函数本身就有此功能,因为任何函数都可以是构造函数,他都有构造器和函数原型,当他们作为属性时,this 时指向的是自身的对象; 例如: 我们在全局中声明的函数实际上是window对象的一个属性 1234function foo(name)&#123; console.log(this) //打印出window对象 this.name = name&#125; 对于构造函数或者函数中方法我们可以使用call和apply改变上下文 例如: 1234接上个例子:var a = &#123;&#125;;foo.call(a,&quot;hellow&quot;);console.log(a.name) call在调用时就相当于执行了该函数的方法,并将上下文对象指向了传入的对象, 这样我们可以看到比较经典的例子 12345function foo(name,age)&#123; var newArr = Array.prototype.slice.call(arguments); console.log(newArr);&#125;foo(&quot;xiaoming&quot;,20); 由于arguments是一个伪数组,并不可以使用Array原型中的方法,对于数组的方法我们没办法使用,就可以使用call方法借调数组原型中的方法,当然一切皆对象,虽然一般没人这样写,但是为了更进一步理解,我们也写了下面的例子: 123456function foo(name)&#123; var name = name; var arr = String.prototype.split.call(name,&quot;&quot;); console.log(arr);&#125;foo(&quot;xiaoming&quot;); 也就是说凡是其他函数中用this写的操作,我们都可以写成上面这种方式进行调用; 甚至dom对象也可以通过该方法调用,简直就是方便的不要不要的,比如原文中的这个案例: 12345function setColor(color)&#123; this.style.backgroundColor = color;&#125;var body = document.body;setColor.call(body,&quot;red&quot;); 当然为了简化和让代码看起来干净,目的明确,原文中写成 1234567function setColor(color)&#123; this.style.backgroundColor = color;&#125;function setBodyColor(color)&#123; setColor.call(document.body,color);&#125;setBodyColor(&quot;red&quot;); (那,当变量名无法展示该行代码的功能时,我们就有必要对该行代码进行封装) 还有一种不容易看出来的上下文就是事件中的上下文,事件中的this,是指向调用该事件的元素; 1234var div = document.queryselector(&quot;div&quot;);div.onclick = function()&#123; this.style.backgroundColor = blue&#125; 面向对象的基础面向对象的基础小节当中主要分为以下几个知识点 1.对象 2.自定义对象的创建 3.静态方法 对象的基础知识大家基本都有理解,那么我们从创建开始讲起: 原文案例: 1234567function User()&#123; this.name = &quot;go&quot;;&#125;//通过构造器创建一个 User 对象var me = new User();var you = new me.constructor();console.log(me.constructor == you.constructor); 事实上每一个对象的都是通过构造器创建的,这样的创建缺点就是,实例中每一个从构造器继承过来的属性都被隐式的创建了新的引用; 接上一个案例: 1234me=&#123;&#125;;me.name = &quot;go&quot;;you = &#123;&#125;;you.name = &quot;go&quot;; 你的疑惑就是,”我知道了,原来是这样,但是并没有什么问题啊”,问题就在于如果内部有一个方法,那么他也会被拷贝多份,这样也占用了大量的内存; 公共方法(public method)因此除了构造器继承以外,还有原型继承,对于的是原文中的:公共方法 原文案例: 123456789function User(name,age)&#123; this.name = name; this.age = age;&#125;;User.prototype.getName = function()&#123;return this.name&#125;;User.prototype.getAge = function()&#123;return this.age&#125;;var user = new User(&quot;Bob&quot;,44);alert( user.getName() == &quot;Bob&quot;);alert( user.getAge() == &quot;44&quot;); 这样的好处就是,公共方法中所有实例化的对象都无需创建新的引用便可以使用,可以优化内存 私有方法(private method)原文案例: 12345678910function Classroom( students, teacher)&#123; function disp()&#123; alert(this.names.join(&quot;,&quot;)); &#125; this.students = students; this.teacher = teacher; disp();&#125;var class = new Classroom([&quot;John&quot;, &quot;Bob&quot;], &quot;Mr.Smith&quot;)class.disp(); //调用失败,因为disp()是一个私有方法; 原文解释: 私有方法和私有变量在保证代码没有冲突的同时,允许你对用户能使用和能看到的内容有更好的控制. 个人理解: ​ 完美报错,错误一:this.names并没有值;是一个undefined; ​ 错误二:占用了class关键字 ​ 这是由于书籍版本的原因,历史原因在此不作讨论了,也不能说人家就错,但是错误一就有点奇怪了,应该再传入一个参数给this.names;应该写为如下 12345678910function Classroom( students, teacher,name)&#123; function disp()&#123; this.names = name console.log(this.names) &#125; this.students = students; this.teacher = teacher; disp();&#125;var class = new Classroom([&quot;John&quot;, &quot;Bob&quot;], &quot;Mr.Smith&quot;,&quot;myName&quot;) 这样,在new一个对象时,也可以做一些操作; 特权方法(privileged method) 用来指代那些在查看并处理(对象中)私有变量的同时允许用户以公共方法的方式访问的方法; 原文案例: 123456789function User(name ,age)&#123; var year = (new Date()).getFullYear() - age; this.getYearBorn = function ()&#123; return year; &#125;;&#125;var user = new User(&quot;Bob&quot;,44);alert(user.getYearBorn() == 1973); //turealert(user.year == null); 本质上,特权方法是动态生成的,因为他们是运行时才添加到对象中的,而不是在代码第一次编译时就已经生成的.虽然这个技巧要比对象的原型继承开销更大,但工功能也更强、和灵活 这里原文中写的很好，就不再解析了； 4.静态方法（static method） 静态方法的实质与任何其他的一般函数没有什么不同,最主要的区别在于,其他函数是以对象的静态属性形式存在的.作为一个属性他们不能在该对象的实例的上下稳中访问,而只属于主对象本身的那个上下文中. 实际上,这样编写代码的唯一有点是保证对象命名空间的整洁 原文例子: 123456User.cloneUser = function(user)&#123; return new User&#123; user.getName(), user.getAge() &#125;&#125; 拓展,这也是 jQuery 中仅仅只使用一个 $ 就可以将所有函数封装的方式,因此在编写功能性强大的框架时,可以使用该方法保持清洁的命名空间; 面向对象的基础小结 开发出专业的 javascript 代码的根本方法之一是,快速、静态地提供与其他代码的接口，同时保证自身的可理解性！ 拓展为了扩展视野,我们来看jQuery中的源码仿写: 12345678910111213141516(function()&#123; var A = function(num)&#123; return A.fn.init(num) &#125;; A.fn = A.prototype=&#123; init:function(num)&#123; this.ele = num; return this; &#125;, print:function()&#123; console.log(this.ele); &#125; &#125; window.$ = A; &#125;)(); $(&apos;20&apos;).print(); 这是多么有艺术的一段代码啊!如果觉得有些负责也没有关系，在本文最后,我会为大家带来Jquery封装的实现的步骤和推演,让你轻松看懂这段代码的艺术,但现在,我们还需要学习更多知识来做为储备; 创建可重用的代码标准化面向对象的代码原型式继承​ 从原文中仿写的例子: 123456789101112function User()&#123; this.name = &quot;jhon&quot;;&#125;;User.prototype.getName = function()&#123; return this.name;&#125;;function Person()&#123;&#125;;Person.prototype = new User(); //重点理解!var person = new Person();console.log(person.name); //jhon 这段代码的作用是在以后通过 Person 实例化后的对象,都拥有了 User 的方法,当然后面还讲到了通过该继承方式来进行模拟 Java 语言中的 类继承 的例子,但是ES6中有类似功能,因此在此只作为理解使用; 该例子隐藏了很多个知识点: 1.当创建一个对象实例时,该对象的__proto__属性指向了父级对象 例如: 12345function Person()&#123; this.name = &quot;jhon&quot;&#125;var obj = new Personconsole.log(obj.__proto__); 可以打印person.__proto__来进行查看; 2.当一个对象实例查找一个属性时,会先从自身属性查找,当自身没有时会查找构造函数的构造器,当构造器中也没有时将查找到构造函数的原型 后面的更多写的是基于上面这个例子所写的一些其他人写的仿Class继承的类库,由于ES6实现了很多类似的继承,那么不再拓展,面向对象这一篇章也就算完结了,现在是看这书的第5天,看书工作加消化和书写,也是一场知识与脑力的碰撞,可能写的有点乱,如果有不妥的地方,可以联系我哟.也请如果有转载,请注明出处,谢谢!文章最后的JQ仿写可以参考我的另外一篇文章 !《Jquery仿写》 ### ​ ​ ​","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]}]